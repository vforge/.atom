"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const languageclient_1 = require("../languageclient");
const convert_1 = require("../convert");
const utils_1 = require("../utils");
const atom_1 = require("atom");
// Public: Adapts the documentSymbolProvider of the language server to the Outline View
// supplied by Atom IDE UI.
class OutlineViewAdapter {
    constructor() {
        this._cancellationTokens = new WeakMap();
    }
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing a documentSymbolProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return serverCapabilities.documentSymbolProvider === true;
    }
    // Public: Obtain the Outline for document via the {LanguageClientConnection} as identified
    // by the {TextEditor}.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will be queried
    //                for the outline.
    // * `editor` The Atom {TextEditor} containing the text the Outline should represent.
    //
    // Returns a {Promise} containing the {Outline} of this document.
    getOutline(connection, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield utils_1.default.doWithCancellationToken(connection, this._cancellationTokens, (cancellationToken) => connection.documentSymbol({ textDocument: convert_1.default.editorToTextDocumentIdentifier(editor) }, cancellationToken));
            results.sort((a, b) => (a.location.range.start.line === b.location.range.start.line
                ? a.location.range.start.character - b.location.range.start.character
                : a.location.range.start.line - b.location.range.start.line));
            return {
                outlineTrees: OutlineViewAdapter.createOutlineTrees(results),
            };
        });
    }
    // Public: Create an {Array} of {OutlineTree}s from the Array of {SymbolInformation} recieved
    // from the language server. This includes determining the appropriate child and parent
    // relationships for the hierarchy.
    //
    // * `symbols` An {Array} of {SymbolInformation}s received from the language server that
    //             should be converted to an {OutlineTree}.
    //
    // Returns an {OutlineTree} containing the given symbols that the Outline View can display.
    static createOutlineTrees(symbols) {
        // Temporarily keep containerName through the conversion process
        // Also filter out symbols without a name - it's part of the spec but some don't include it
        const allItems = symbols.filter((symbol) => symbol.name).map((symbol) => ({
            containerName: symbol.containerName,
            outline: OutlineViewAdapter.symbolToOutline(symbol),
        }));
        // Create a map of containers by name with all items that have that name
        const containers = allItems.reduce((map, item) => {
            const name = item.outline.representativeName;
            if (name != null) {
                const container = map.get(name);
                if (container == null) {
                    map.set(name, [item.outline]);
                }
                else {
                    container.push(item.outline);
                }
            }
            return map;
        }, new Map());
        const roots = [];
        // Put each item within its parent and extract out the roots
        for (const item of allItems) {
            const containerName = item.containerName;
            const child = item.outline;
            if (containerName == null || containerName === '') {
                roots.push(item.outline);
            }
            else {
                const possibleParents = containers.get(containerName);
                let closestParent = OutlineViewAdapter._getClosestParent(possibleParents, child);
                if (closestParent == null) {
                    closestParent = {
                        plainText: containerName,
                        representativeName: containerName,
                        startPosition: new atom_1.Point(0, 0),
                        children: [child],
                    };
                    roots.push(closestParent);
                    if (possibleParents == null) {
                        containers.set(containerName, [closestParent]);
                    }
                    else {
                        possibleParents.push(closestParent);
                    }
                }
                else {
                    closestParent.children.push(child);
                }
            }
        }
        return roots;
    }
    static _getClosestParent(candidates, child) {
        if (candidates == null || candidates.length === 0) {
            return null;
        }
        let parent;
        for (const candidate of candidates) {
            if (candidate !== child &&
                candidate.startPosition.isLessThanOrEqual(child.startPosition) &&
                (candidate.endPosition === undefined ||
                    (child.endPosition && candidate.endPosition.isGreaterThanOrEqual(child.endPosition)))) {
                if (parent === undefined ||
                    (parent.startPosition.isLessThanOrEqual(candidate.startPosition) ||
                        (parent.endPosition != null &&
                            candidate.endPosition &&
                            parent.endPosition.isGreaterThanOrEqual(candidate.endPosition)))) {
                    parent = candidate;
                }
            }
        }
        return parent || null;
    }
    // Public: Convert an individual {SymbolInformation} from the language server
    // to an {OutlineTree} for use by the Outline View.
    //
    // * `symbol` The {SymbolInformation} to convert to an {OutlineTree}.
    //
    // Returns the {OutlineTree} equivalent to the given {SymbolInformation}.
    static symbolToOutline(symbol) {
        const icon = OutlineViewAdapter.symbolKindToEntityKind(symbol.kind);
        return {
            tokenizedText: [
                {
                    kind: OutlineViewAdapter.symbolKindToTokenKind(symbol.kind),
                    value: symbol.name,
                },
            ],
            icon: icon != null ? icon : undefined,
            representativeName: symbol.name,
            startPosition: convert_1.default.positionToPoint(symbol.location.range.start),
            endPosition: convert_1.default.positionToPoint(symbol.location.range.end),
            children: [],
        };
    }
    // Public: Convert a symbol kind into an outline entity kind used to determine
    // the styling such as the appropriate icon in the Outline View.
    //
    // * `symbol` The numeric symbol kind received from the language server.
    //
    // Returns a string representing the equivalent OutlineView entity kind.
    static symbolKindToEntityKind(symbol) {
        switch (symbol) {
            case languageclient_1.SymbolKind.Array:
                return 'type-array';
            case languageclient_1.SymbolKind.Boolean:
                return 'type-boolean';
            case languageclient_1.SymbolKind.Class:
                return 'type-class';
            case languageclient_1.SymbolKind.Constant:
                return 'type-constant';
            case languageclient_1.SymbolKind.Constructor:
                return 'type-constructor';
            case languageclient_1.SymbolKind.Enum:
                return 'type-enum';
            case languageclient_1.SymbolKind.Field:
                return 'type-field';
            case languageclient_1.SymbolKind.File:
                return 'type-file';
            case languageclient_1.SymbolKind.Function:
                return 'type-function';
            case languageclient_1.SymbolKind.Interface:
                return 'type-interface';
            case languageclient_1.SymbolKind.Method:
                return 'type-method';
            case languageclient_1.SymbolKind.Module:
                return 'type-module';
            case languageclient_1.SymbolKind.Namespace:
                return 'type-namespace';
            case languageclient_1.SymbolKind.Number:
                return 'type-number';
            case languageclient_1.SymbolKind.Package:
                return 'type-package';
            case languageclient_1.SymbolKind.Property:
                return 'type-property';
            case languageclient_1.SymbolKind.String:
                return 'type-string';
            case languageclient_1.SymbolKind.Variable:
                return 'type-variable';
            default:
                return null;
        }
    }
    // Public: Convert a symbol kind to the appropriate token kind used to syntax
    // highlight the symbol name in the Outline View.
    //
    // * `symbol` The numeric symbol kind received from the language server.
    //
    // Returns a string representing the equivalent syntax token kind.
    static symbolKindToTokenKind(symbol) {
        switch (symbol) {
            case languageclient_1.SymbolKind.Class:
                return 'type';
            case languageclient_1.SymbolKind.Constructor:
                return 'constructor';
            case languageclient_1.SymbolKind.Method:
            case languageclient_1.SymbolKind.Function:
                return 'method';
            case languageclient_1.SymbolKind.String:
                return 'string';
            default:
                return 'plain';
        }
    }
}
exports.default = OutlineViewAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3V0bGluZS12aWV3LWFkYXB0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRhcHRlcnMvb3V0bGluZS12aWV3LWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLHNEQUFnSDtBQUNoSCx3Q0FBaUM7QUFDakMsb0NBQTZCO0FBQzdCLCtCQUF5QztBQUl6Qyx1RkFBdUY7QUFDdkYsMkJBQTJCO0FBQzNCO0lBQUE7UUFFVSx3QkFBbUIsR0FBK0QsSUFBSSxPQUFPLEVBQUUsQ0FBQztJQStOMUcsQ0FBQztJQTdOQyxnRkFBZ0Y7SUFDaEYsOEVBQThFO0lBQzlFLEVBQUU7SUFDRixzRkFBc0Y7SUFDdEYsRUFBRTtJQUNGLDJFQUEyRTtJQUMzRSw0QkFBNEI7SUFDckIsTUFBTSxDQUFDLFFBQVEsQ0FBQyxrQkFBc0M7UUFDM0QsTUFBTSxDQUFDLGtCQUFrQixDQUFDLHNCQUFzQixLQUFLLElBQUksQ0FBQztJQUM1RCxDQUFDO0lBRUQsMkZBQTJGO0lBQzNGLHVCQUF1QjtJQUN2QixFQUFFO0lBQ0YsMEZBQTBGO0lBQzFGLGtDQUFrQztJQUNsQyxxRkFBcUY7SUFDckYsRUFBRTtJQUNGLGlFQUFpRTtJQUNwRCxVQUFVLENBQUMsVUFBb0MsRUFBRSxNQUFrQjs7WUFDOUUsTUFBTSxPQUFPLEdBQUcsTUFBTSxlQUFLLENBQUMsdUJBQXVCLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLGlCQUFpQixFQUFFLEVBQUUsQ0FDOUcsVUFBVSxDQUFDLGNBQWMsQ0FBQyxFQUFDLFlBQVksRUFBRSxpQkFBTyxDQUFDLDhCQUE4QixDQUFDLE1BQU0sQ0FBQyxFQUFDLEVBQUUsaUJBQWlCLENBQUMsQ0FDN0csQ0FBQztZQUNGLE9BQU8sQ0FBQyxJQUFJLENBQ1YsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FDUCxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FB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QUM7WUFDbEI7Z0JBQ0UsTUFBTSxDQUFDLE9BQU8sQ0FBQztRQUNuQixDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBak9ELHFDQWlPQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgU3ltYm9sS2luZCwgU2VydmVyQ2FwYWJpbGl0aWVzLCBTeW1ib2xJbmZvcm1hdGlvbiB9IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFBvaW50LCBUZXh0RWRpdG9yIH0gZnJvbSAnYXRvbSc7XG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB9IGZyb20gJ3ZzY29kZS1qc29ucnBjJztcbmltcG9ydCAqIGFzIGF0b21JZGUgZnJvbSAnYXRvbS1pZGUnO1xuXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgZG9jdW1lbnRTeW1ib2xQcm92aWRlciBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIHRoZSBPdXRsaW5lIFZpZXdcbi8vIHN1cHBsaWVkIGJ5IEF0b20gSURFIFVJLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3V0bGluZVZpZXdBZGFwdGVyIHtcblxuICBwcml2YXRlIF9jYW5jZWxsYXRpb25Ub2tlbnM6IFdlYWtNYXA8TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZT4gPSBuZXcgV2Vha01hcCgpO1xuXG4gIC8vIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyXG4gIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IGNvbnRhaW5pbmcgYSBkb2N1bWVudFN5bWJvbFByb3ZpZGVyLlxuICAvL1xuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGNvbnNpZGVyLlxuICAvL1xuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxuICBwdWJsaWMgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFN5bWJvbFByb3ZpZGVyID09PSB0cnVlO1xuICB9XG5cbiAgLy8gUHVibGljOiBPYnRhaW4gdGhlIE91dGxpbmUgZm9yIGRvY3VtZW50IHZpYSB0aGUge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gYXMgaWRlbnRpZmllZFxuICAvLyBieSB0aGUge1RleHRFZGl0b3J9LlxuICAvL1xuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGJlIHF1ZXJpZWRcbiAgLy8gICAgICAgICAgICAgICAgZm9yIHRoZSBvdXRsaW5lLlxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoZSBPdXRsaW5lIHNob3VsZCByZXByZXNlbnQuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gY29udGFpbmluZyB0aGUge091dGxpbmV9IG9mIHRoaXMgZG9jdW1lbnQuXG4gIHB1YmxpYyBhc3luYyBnZXRPdXRsaW5lKGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgZWRpdG9yOiBUZXh0RWRpdG9yKTogUHJvbWlzZTxhdG9tSWRlLk91dGxpbmUgfCBudWxsPiB7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFV0aWxzLmRvV2l0aENhbmNlbGxhdGlvblRva2VuKGNvbm5lY3Rpb24sIHRoaXMuX2NhbmNlbGxhdGlvblRva2VucywgKGNhbmNlbGxhdGlvblRva2VuKSA9PlxuICAgICAgY29ubmVjdGlvbi5kb2N1bWVudFN5bWJvbCh7dGV4dERvY3VtZW50OiBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihlZGl0b3IpfSwgY2FuY2VsbGF0aW9uVG9rZW4pLFxuICAgICk7XG4gICAgcmVzdWx0cy5zb3J0KFxuICAgICAgKGEsIGIpID0+XG4gICAgICAgIChhLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmxpbmUgPT09IGIubG9jYXRpb24ucmFuZ2Uuc3RhcnQubGluZVxuICAgICAgICAgID8gYS5sb2NhdGlvbi5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmNoYXJhY3RlclxuICAgICAgICAgIDogYS5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lIC0gYi5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lKSxcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBvdXRsaW5lVHJlZXM6IE91dGxpbmVWaWV3QWRhcHRlci5jcmVhdGVPdXRsaW5lVHJlZXMocmVzdWx0cyksXG4gICAgfTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ3JlYXRlIGFuIHtBcnJheX0gb2Yge091dGxpbmVUcmVlfXMgZnJvbSB0aGUgQXJyYXkgb2Yge1N5bWJvbEluZm9ybWF0aW9ufSByZWNpZXZlZFxuICAvLyBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuIFRoaXMgaW5jbHVkZXMgZGV0ZXJtaW5pbmcgdGhlIGFwcHJvcHJpYXRlIGNoaWxkIGFuZCBwYXJlbnRcbiAgLy8gcmVsYXRpb25zaGlwcyBmb3IgdGhlIGhpZXJhcmNoeS5cbiAgLy9cbiAgLy8gKiBgc3ltYm9sc2AgQW4ge0FycmF5fSBvZiB7U3ltYm9sSW5mb3JtYXRpb259cyByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdFxuICAvLyAgICAgICAgICAgICBzaG91bGQgYmUgY29udmVydGVkIHRvIGFuIHtPdXRsaW5lVHJlZX0uXG4gIC8vXG4gIC8vIFJldHVybnMgYW4ge091dGxpbmVUcmVlfSBjb250YWluaW5nIHRoZSBnaXZlbiBzeW1ib2xzIHRoYXQgdGhlIE91dGxpbmUgVmlldyBjYW4gZGlzcGxheS5cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVPdXRsaW5lVHJlZXMoc3ltYm9sczogU3ltYm9sSW5mb3JtYXRpb25bXSk6IGF0b21JZGUuT3V0bGluZVRyZWVbXSB7XG4gICAgLy8gVGVtcG9yYXJpbHkga2VlcCBjb250YWluZXJOYW1lIHRocm91Z2ggdGhlIGNvbnZlcnNpb24gcHJvY2Vzc1xuICAgIC8vIEFsc28gZmlsdGVyIG91dCBzeW1ib2xzIHdpdGhvdXQgYSBuYW1lIC0gaXQncyBwYXJ0IG9mIHRoZSBzcGVjIGJ1dCBzb21lIGRvbid0IGluY2x1ZGUgaXRcbiAgICBjb25zdCBhbGxJdGVtcyA9IHN5bWJvbHMuZmlsdGVyKChzeW1ib2wpID0+IHN5bWJvbC5uYW1lKS5tYXAoKHN5bWJvbCkgPT4gKHtcbiAgICAgIGNvbnRhaW5lck5hbWU6IHN5bWJvbC5jb250YWluZXJOYW1lLFxuICAgICAgb3V0bGluZTogT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbFRvT3V0bGluZShzeW1ib2wpLFxuICAgIH0pKTtcblxuICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBjb250YWluZXJzIGJ5IG5hbWUgd2l0aCBhbGwgaXRlbXMgdGhhdCBoYXZlIHRoYXQgbmFtZVxuICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBhbGxJdGVtcy5yZWR1Y2UoKG1hcCwgaXRlbSkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGl0ZW0ub3V0bGluZS5yZXByZXNlbnRhdGl2ZU5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmIChjb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgIG1hcC5zZXQobmFtZSwgW2l0ZW0ub3V0bGluZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lci5wdXNoKGl0ZW0ub3V0bGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgbmV3IE1hcCgpKTtcblxuICAgIGNvbnN0IHJvb3RzOiBhdG9tSWRlLk91dGxpbmVUcmVlW10gPSBbXTtcblxuICAgIC8vIFB1dCBlYWNoIGl0ZW0gd2l0aGluIGl0cyBwYXJlbnQgYW5kIGV4dHJhY3Qgb3V0IHRoZSByb290c1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhbGxJdGVtcykge1xuICAgICAgY29uc3QgY29udGFpbmVyTmFtZSA9IGl0ZW0uY29udGFpbmVyTmFtZTtcbiAgICAgIGNvbnN0IGNoaWxkID0gaXRlbS5vdXRsaW5lO1xuICAgICAgaWYgKGNvbnRhaW5lck5hbWUgPT0gbnVsbCB8fCBjb250YWluZXJOYW1lID09PSAnJykge1xuICAgICAgICByb290cy5wdXNoKGl0ZW0ub3V0bGluZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwb3NzaWJsZVBhcmVudHMgPSBjb250YWluZXJzLmdldChjb250YWluZXJOYW1lKTtcbiAgICAgICAgbGV0IGNsb3Nlc3RQYXJlbnQgPSBPdXRsaW5lVmlld0FkYXB0ZXIuX2dldENsb3Nlc3RQYXJlbnQocG9zc2libGVQYXJlbnRzLCBjaGlsZCk7XG4gICAgICAgIGlmIChjbG9zZXN0UGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgICBjbG9zZXN0UGFyZW50ID0ge1xuICAgICAgICAgICAgcGxhaW5UZXh0OiBjb250YWluZXJOYW1lLFxuICAgICAgICAgICAgcmVwcmVzZW50YXRpdmVOYW1lOiBjb250YWluZXJOYW1lLFxuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbjogbmV3IFBvaW50KDAsIDApLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtjaGlsZF0sXG4gICAgICAgICAgfTtcbiAgICAgICAgICByb290cy5wdXNoKGNsb3Nlc3RQYXJlbnQpO1xuICAgICAgICAgIGlmIChwb3NzaWJsZVBhcmVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGFpbmVycy5zZXQoY29udGFpbmVyTmFtZSwgW2Nsb3Nlc3RQYXJlbnRdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zc2libGVQYXJlbnRzLnB1c2goY2xvc2VzdFBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3Nlc3RQYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdHM7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBfZ2V0Q2xvc2VzdFBhcmVudChcbiAgICBjYW5kaWRhdGVzOiBhdG9tSWRlLk91dGxpbmVUcmVlW10gfCBudWxsLFxuICAgIGNoaWxkOiBhdG9tSWRlLk91dGxpbmVUcmVlLFxuICApOiBhdG9tSWRlLk91dGxpbmVUcmVlIHwgbnVsbCB7XG4gICAgaWYgKGNhbmRpZGF0ZXMgPT0gbnVsbCB8fCBjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHBhcmVudDogYXRvbUlkZS5PdXRsaW5lVHJlZSB8IHVuZGVmaW5lZDtcbiAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNhbmRpZGF0ZSAhPT0gY2hpbGQgJiZcbiAgICAgICAgY2FuZGlkYXRlLnN0YXJ0UG9zaXRpb24uaXNMZXNzVGhhbk9yRXF1YWwoY2hpbGQuc3RhcnRQb3NpdGlvbikgJiZcbiAgICAgICAgKGNhbmRpZGF0ZS5lbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGNoaWxkLmVuZFBvc2l0aW9uICYmIGNhbmRpZGF0ZS5lbmRQb3NpdGlvbi5pc0dyZWF0ZXJUaGFuT3JFcXVhbChjaGlsZC5lbmRQb3NpdGlvbikpKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwYXJlbnQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIChwYXJlbnQuc3RhcnRQb3NpdGlvbi5pc0xlc3NUaGFuT3JFcXVhbChjYW5kaWRhdGUuc3RhcnRQb3NpdGlvbikgfHxcbiAgICAgICAgICAgIChwYXJlbnQuZW5kUG9zaXRpb24gIT0gbnVsbCAmJlxuICAgICAgICAgICAgICBjYW5kaWRhdGUuZW5kUG9zaXRpb24gJiZcbiAgICAgICAgICAgICAgcGFyZW50LmVuZFBvc2l0aW9uLmlzR3JlYXRlclRoYW5PckVxdWFsKGNhbmRpZGF0ZS5lbmRQb3NpdGlvbikpKVxuICAgICAgICApIHtcbiAgICAgICAgICBwYXJlbnQgPSBjYW5kaWRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50IHx8IG51bGw7XG4gIH1cblxuICAvLyBQdWJsaWM6IENvbnZlcnQgYW4gaW5kaXZpZHVhbCB7U3ltYm9sSW5mb3JtYXRpb259IGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlclxuICAvLyB0byBhbiB7T3V0bGluZVRyZWV9IGZvciB1c2UgYnkgdGhlIE91dGxpbmUgVmlldy5cbiAgLy9cbiAgLy8gKiBgc3ltYm9sYCBUaGUge1N5bWJvbEluZm9ybWF0aW9ufSB0byBjb252ZXJ0IHRvIGFuIHtPdXRsaW5lVHJlZX0uXG4gIC8vXG4gIC8vIFJldHVybnMgdGhlIHtPdXRsaW5lVHJlZX0gZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4ge1N5bWJvbEluZm9ybWF0aW9ufS5cbiAgcHVibGljIHN0YXRpYyBzeW1ib2xUb091dGxpbmUoc3ltYm9sOiBTeW1ib2xJbmZvcm1hdGlvbik6IGF0b21JZGUuT3V0bGluZVRyZWUge1xuICAgIGNvbnN0IGljb24gPSBPdXRsaW5lVmlld0FkYXB0ZXIuc3ltYm9sS2luZFRvRW50aXR5S2luZChzeW1ib2wua2luZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuaXplZFRleHQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIGtpbmQ6IE91dGxpbmVWaWV3QWRhcHRlci5zeW1ib2xLaW5kVG9Ub2tlbktpbmQoc3ltYm9sLmtpbmQpLFxuICAgICAgICAgIHZhbHVlOiBzeW1ib2wubmFtZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBpY29uOiBpY29uICE9IG51bGwgPyBpY29uIDogdW5kZWZpbmVkLFxuICAgICAgcmVwcmVzZW50YXRpdmVOYW1lOiBzeW1ib2wubmFtZSxcbiAgICAgIHN0YXJ0UG9zaXRpb246IENvbnZlcnQucG9zaXRpb25Ub1BvaW50KHN5bWJvbC5sb2NhdGlvbi5yYW5nZS5zdGFydCksXG4gICAgICBlbmRQb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoc3ltYm9sLmxvY2F0aW9uLnJhbmdlLmVuZCksXG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgfTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIHN5bWJvbCBraW5kIGludG8gYW4gb3V0bGluZSBlbnRpdHkga2luZCB1c2VkIHRvIGRldGVybWluZVxuICAvLyB0aGUgc3R5bGluZyBzdWNoIGFzIHRoZSBhcHByb3ByaWF0ZSBpY29uIGluIHRoZSBPdXRsaW5lIFZpZXcuXG4gIC8vXG4gIC8vICogYHN5bWJvbGAgVGhlIG51bWVyaWMgc3ltYm9sIGtpbmQgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxuICAvL1xuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXF1aXZhbGVudCBPdXRsaW5lVmlldyBlbnRpdHkga2luZC5cbiAgcHVibGljIHN0YXRpYyBzeW1ib2xLaW5kVG9FbnRpdHlLaW5kKHN5bWJvbDogbnVtYmVyKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgc3dpdGNoIChzeW1ib2wpIHtcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5BcnJheTpcbiAgICAgICAgcmV0dXJuICd0eXBlLWFycmF5JztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Cb29sZWFuOlxuICAgICAgICByZXR1cm4gJ3R5cGUtYm9vbGVhbic7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ2xhc3M6XG4gICAgICAgIHJldHVybiAndHlwZS1jbGFzcyc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ29uc3RhbnQ6XG4gICAgICAgIHJldHVybiAndHlwZS1jb25zdGFudCc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ29uc3RydWN0b3I6XG4gICAgICAgIHJldHVybiAndHlwZS1jb25zdHJ1Y3Rvcic7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRW51bTpcbiAgICAgICAgcmV0dXJuICd0eXBlLWVudW0nO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZpZWxkOlxuICAgICAgICByZXR1cm4gJ3R5cGUtZmllbGQnO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZpbGU6XG4gICAgICAgIHJldHVybiAndHlwZS1maWxlJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5GdW5jdGlvbjpcbiAgICAgICAgcmV0dXJuICd0eXBlLWZ1bmN0aW9uJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5JbnRlcmZhY2U6XG4gICAgICAgIHJldHVybiAndHlwZS1pbnRlcmZhY2UnO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLk1ldGhvZDpcbiAgICAgICAgcmV0dXJuICd0eXBlLW1ldGhvZCc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTW9kdWxlOlxuICAgICAgICByZXR1cm4gJ3R5cGUtbW9kdWxlJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5OYW1lc3BhY2U6XG4gICAgICAgIHJldHVybiAndHlwZS1uYW1lc3BhY2UnO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLk51bWJlcjpcbiAgICAgICAgcmV0dXJuICd0eXBlLW51bWJlcic7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuUGFja2FnZTpcbiAgICAgICAgcmV0dXJuICd0eXBlLXBhY2thZ2UnO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLlByb3BlcnR5OlxuICAgICAgICByZXR1cm4gJ3R5cGUtcHJvcGVydHknO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLlN0cmluZzpcbiAgICAgICAgcmV0dXJuICd0eXBlLXN0cmluZyc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuVmFyaWFibGU6XG4gICAgICAgIHJldHVybiAndHlwZS12YXJpYWJsZSc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBzeW1ib2wga2luZCB0byB0aGUgYXBwcm9wcmlhdGUgdG9rZW4ga2luZCB1c2VkIHRvIHN5bnRheFxuICAvLyBoaWdobGlnaHQgdGhlIHN5bWJvbCBuYW1lIGluIHRoZSBPdXRsaW5lIFZpZXcuXG4gIC8vXG4gIC8vICogYHN5bWJvbGAgVGhlIG51bWVyaWMgc3ltYm9sIGtpbmQgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxuICAvL1xuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXF1aXZhbGVudCBzeW50YXggdG9rZW4ga2luZC5cbiAgcHVibGljIHN0YXRpYyBzeW1ib2xLaW5kVG9Ub2tlbktpbmQoc3ltYm9sOiBudW1iZXIpOiBhdG9tSWRlLlRva2VuS2luZCB7XG4gICAgc3dpdGNoIChzeW1ib2wpIHtcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5DbGFzczpcbiAgICAgICAgcmV0dXJuICd0eXBlJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdHJ1Y3RvcjpcbiAgICAgICAgcmV0dXJuICdjb25zdHJ1Y3Rvcic7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTWV0aG9kOlxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZ1bmN0aW9uOlxuICAgICAgICByZXR1cm4gJ21ldGhvZCc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuU3RyaW5nOlxuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJ3BsYWluJztcbiAgICB9XG4gIH1cbn1cbiJdfQ==