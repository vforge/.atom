"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
class FindReferencesAdapter {
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing a referencesProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return serverCapabilities.referencesProvider === true;
    }
    // Public: Get the references for a specific symbol within the document as represented by
    // the {TextEditor} and {Point} within it via the language server.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will be queried
    //                for the references.
    // * `editor` The Atom {TextEditor} containing the text the references should relate to.
    // * `point` The Atom {Point} containing the point within the text the references should relate to.
    //
    // Returns a {Promise} containing a {FindReferencesReturn} with all the references the language server
    // could find.
    getReferences(connection, editor, point, projectRoot) {
        return __awaiter(this, void 0, void 0, function* () {
            const locations = yield connection.findReferences(FindReferencesAdapter.createReferenceParams(editor, point));
            if (locations == null) {
                return null;
            }
            const references = locations.map(FindReferencesAdapter.locationToReference);
            return {
                type: 'data',
                baseUri: projectRoot || '',
                referencedSymbolName: FindReferencesAdapter.getReferencedSymbolName(editor, point, references),
                references,
            };
        });
    }
    // Public: Create a {ReferenceParams} from a given {TextEditor} for a specific {Point}.
    //
    // * `editor` A {TextEditor} that represents the document.
    // * `point` A {Point} within the document.
    //
    // Returns a {ReferenceParams} built from the given parameters.
    static createReferenceParams(editor, point) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            position: convert_1.default.pointToPosition(point),
            context: { includeDeclaration: true },
        };
    }
    // Public: Convert a {Location} into a {Reference}.
    //
    // * `location` A {Location} to convert.
    //
    // Returns a {Reference} equivalent to the given {Location}.
    static locationToReference(location) {
        return {
            uri: convert_1.default.uriToPath(location.uri),
            name: null,
            range: convert_1.default.lsRangeToAtomRange(location.range),
        };
    }
    // Public: Get a symbol name from a {TextEditor} for a specific {Point} in the document.
    static getReferencedSymbolName(editor, point, references) {
        if (references.length === 0) {
            return '';
        }
        const currentReference = references.find((r) => r.range.containsPoint(point)) || references[0];
        return editor.getBuffer().getTextInRange(currentReference.range);
    }
}
exports.default = FindReferencesAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRhcHRlcnMvZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQVFBLHdDQUFpQztBQUVqQyxnRUFBZ0U7QUFDaEUsd0VBQXdFO0FBQ3hFO0lBQ0UsZ0ZBQWdGO0lBQ2hGLDBFQUEwRTtJQUMxRSxFQUFFO0lBQ0Ysc0ZBQXNGO0lBQ3RGLEVBQUU7SUFDRiwyRUFBMkU7SUFDM0UsNEJBQTRCO0lBQ3JCLE1BQU0sQ0FBQyxRQUFRLENBQUMsa0JBQXNDO1FBQzNELE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxrQkFBa0IsS0FBSyxJQUFJLENBQUM7SUFDeEQsQ0FBQztJQUVELHlGQUF5RjtJQUN6RixrRUFBa0U7SUFDbEUsRUFBRTtJQUNGLDBGQUEwRjtJQUMxRixxQ0FBcUM7SUFDckMsd0ZBQXdGO0lBQ3hGLG1HQUFtRztJQUNuRyxFQUFFO0lBQ0Ysc0dBQXNHO0lBQ3RHLGNBQWM7SUFDRCxhQUFhLENBQ3hCLFVBQW9DLEVBQ3BDLE1BQWtCLEVBQ2xCLEtBQVksRUFDWixXQUEwQjs7WUFFMUIsTUFBTSxTQUFTLEdBQUcsTUFBTSxVQUFVLENBQUMsY0FBYyxDQUMvQyxxQkFBcUIsQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQzNELENBQUM7WUFDRixFQUFFLENBQUMsQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFDdEIsTUFBTSxDQUFDLElBQUksQ0FBQztZQUNkLENBQUM7WUFFRCxNQUFNLFVBQVUsR0FBd0IsU0FBUyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1lBQ2pHLE1BQU0sQ0FBQztnQkFDTCxJQUFJLEVBQUUsTUFBTTtnQkFDWixPQUFPLEVBQUUsV0FBVyxJQUFJLEVBQUU7Z0JBQzFCLG9CQUFvQixFQUFFLHFCQUFxQixDQUFDLHVCQUF1QixDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsVUFBVSxDQUFDO2dCQUM5RixVQUFVO2FBQ1gsQ0FBQztRQUNKLENBQUM7S0FBQTtJQUVELHVGQUF1RjtJQUN2RixFQUFFO0lBQ0YsMERBQTBEO0lBQzFELDJDQUEyQztJQUMzQyxFQUFFO0lBQ0YsK0RBQStEO0lBQ3hELE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxNQUFrQixFQUFFLEtBQVk7UUFDbEUsTUFBTSxDQUFDO1lBQ0wsWUFBWSxFQUFFLGlCQUFPLENBQUMsOEJBQThCLENBQUMsTUFBTSxDQUFDO1lBQzVELFFBQVEsRUFBRSxpQkFBTyxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUM7WUFDeEMsT0FBTyxFQUFFLEVBQUMsa0JBQWtCLEVBQUUsSUFBSSxFQUFDO1NBQ3BDLENBQUM7SUFDSixDQUFDO0lBRUQsbURBQW1EO0lBQ25ELEVBQUU7SUFDRix3Q0FBd0M7SUFDeEMsRUFBRTtJQUNGLDREQUE0RDtJQUNyRCxNQUFNLENBQUMsbUJBQW1CLENBQUMsUUFBa0I7UUFDbEQsTUFBTSxDQUFDO1lBQ0wsR0FBRyxFQUFFLGlCQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUM7WUFDcEMsSUFBSSxFQUFFLElBQUk7WUFDVixLQUFLLEVBQUUsaUJBQU8sQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO1NBQ2xELENBQUM7SUFDSixDQUFDO0lBRUQsd0ZBQXdGO0lBQ2pGLE1BQU0sQ0FBQyx1QkFBdUIsQ0FDbkMsTUFBa0IsRUFDbEIsS0FBWSxFQUNaLFVBQStCO1FBRS9CLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QixNQUFNLENBQUMsRUFBRSxDQUFDO1FBQ1osQ0FBQztRQUNELE1BQU0sZ0JBQWdCLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0YsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkUsQ0FBQztDQUNGO0FBbkZELHdDQW1GQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgTG9jYXRpb24sXG4gIFNlcnZlckNhcGFiaWxpdGllcyxcbiAgUmVmZXJlbmNlUGFyYW1zLFxufSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XG5pbXBvcnQgeyBQb2ludCwgVGV4dEVkaXRvciB9IGZyb20gJ2F0b20nO1xuaW1wb3J0ICogYXMgYXRvbUlkZSBmcm9tICdhdG9tLWlkZSc7XG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcblxuLy8gUHVibGljOiBBZGFwdHMgdGhlIGxhbmd1YWdlIHNlcnZlciBkZWZpbml0aW9uIHByb3ZpZGVyIHRvIHRoZVxuLy8gQXRvbSBJREUgVUkgRGVmaW5pdGlvbnMgcGFja2FnZSBmb3IgJ0dvIFRvIERlZmluaXRpb24nIGZ1bmN0aW9uYWxpdHkuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaW5kUmVmZXJlbmNlc0FkYXB0ZXIge1xuICAvLyBQdWJsaWM6IERldGVybWluZSB3aGV0aGVyIHRoaXMgYWRhcHRlciBjYW4gYmUgdXNlZCB0byBhZGFwdCBhIGxhbmd1YWdlIHNlcnZlclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCBjb250YWluaW5nIGEgcmVmZXJlbmNlc1Byb3ZpZGVyLlxuICAvL1xuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGNvbnNpZGVyLlxuICAvL1xuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxuICBwdWJsaWMgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5yZWZlcmVuY2VzUHJvdmlkZXIgPT09IHRydWU7XG4gIH1cblxuICAvLyBQdWJsaWM6IEdldCB0aGUgcmVmZXJlbmNlcyBmb3IgYSBzcGVjaWZpYyBzeW1ib2wgd2l0aGluIHRoZSBkb2N1bWVudCBhcyByZXByZXNlbnRlZCBieVxuICAvLyB0aGUge1RleHRFZGl0b3J9IGFuZCB7UG9pbnR9IHdpdGhpbiBpdCB2aWEgdGhlIGxhbmd1YWdlIHNlcnZlci5cbiAgLy9cbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSBxdWVyaWVkXG4gIC8vICAgICAgICAgICAgICAgIGZvciB0aGUgcmVmZXJlbmNlcy5cbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgdGV4dCB0aGUgcmVmZXJlbmNlcyBzaG91bGQgcmVsYXRlIHRvLlxuICAvLyAqIGBwb2ludGAgVGhlIEF0b20ge1BvaW50fSBjb250YWluaW5nIHRoZSBwb2ludCB3aXRoaW4gdGhlIHRleHQgdGhlIHJlZmVyZW5jZXMgc2hvdWxkIHJlbGF0ZSB0by5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBjb250YWluaW5nIGEge0ZpbmRSZWZlcmVuY2VzUmV0dXJufSB3aXRoIGFsbCB0aGUgcmVmZXJlbmNlcyB0aGUgbGFuZ3VhZ2Ugc2VydmVyXG4gIC8vIGNvdWxkIGZpbmQuXG4gIHB1YmxpYyBhc3luYyBnZXRSZWZlcmVuY2VzKFxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXG4gICAgcG9pbnQ6IFBvaW50LFxuICAgIHByb2plY3RSb290OiBzdHJpbmcgfCBudWxsLFxuICApOiBQcm9taXNlPGF0b21JZGUuRmluZFJlZmVyZW5jZXNSZXR1cm4gfCBudWxsPiB7XG4gICAgY29uc3QgbG9jYXRpb25zID0gYXdhaXQgY29ubmVjdGlvbi5maW5kUmVmZXJlbmNlcyhcbiAgICAgIEZpbmRSZWZlcmVuY2VzQWRhcHRlci5jcmVhdGVSZWZlcmVuY2VQYXJhbXMoZWRpdG9yLCBwb2ludCksXG4gICAgKTtcbiAgICBpZiAobG9jYXRpb25zID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZmVyZW5jZXM6IGF0b21JZGUuUmVmZXJlbmNlW10gPSBsb2NhdGlvbnMubWFwKEZpbmRSZWZlcmVuY2VzQWRhcHRlci5sb2NhdGlvblRvUmVmZXJlbmNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgYmFzZVVyaTogcHJvamVjdFJvb3QgfHwgJycsXG4gICAgICByZWZlcmVuY2VkU3ltYm9sTmFtZTogRmluZFJlZmVyZW5jZXNBZGFwdGVyLmdldFJlZmVyZW5jZWRTeW1ib2xOYW1lKGVkaXRvciwgcG9pbnQsIHJlZmVyZW5jZXMpLFxuICAgICAgcmVmZXJlbmNlcyxcbiAgICB9O1xuICB9XG5cbiAgLy8gUHVibGljOiBDcmVhdGUgYSB7UmVmZXJlbmNlUGFyYW1zfSBmcm9tIGEgZ2l2ZW4ge1RleHRFZGl0b3J9IGZvciBhIHNwZWNpZmljIHtQb2ludH0uXG4gIC8vXG4gIC8vICogYGVkaXRvcmAgQSB7VGV4dEVkaXRvcn0gdGhhdCByZXByZXNlbnRzIHRoZSBkb2N1bWVudC5cbiAgLy8gKiBgcG9pbnRgIEEge1BvaW50fSB3aXRoaW4gdGhlIGRvY3VtZW50LlxuICAvL1xuICAvLyBSZXR1cm5zIGEge1JlZmVyZW5jZVBhcmFtc30gYnVpbHQgZnJvbSB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVSZWZlcmVuY2VQYXJhbXMoZWRpdG9yOiBUZXh0RWRpdG9yLCBwb2ludDogUG9pbnQpOiBSZWZlcmVuY2VQYXJhbXMge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXG4gICAgICBwb3NpdGlvbjogQ29udmVydC5wb2ludFRvUG9zaXRpb24ocG9pbnQpLFxuICAgICAgY29udGV4dDoge2luY2x1ZGVEZWNsYXJhdGlvbjogdHJ1ZX0sXG4gICAgfTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIHtMb2NhdGlvbn0gaW50byBhIHtSZWZlcmVuY2V9LlxuICAvL1xuICAvLyAqIGBsb2NhdGlvbmAgQSB7TG9jYXRpb259IHRvIGNvbnZlcnQuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7UmVmZXJlbmNlfSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiB7TG9jYXRpb259LlxuICBwdWJsaWMgc3RhdGljIGxvY2F0aW9uVG9SZWZlcmVuY2UobG9jYXRpb246IExvY2F0aW9uKTogYXRvbUlkZS5SZWZlcmVuY2Uge1xuICAgIHJldHVybiB7XG4gICAgICB1cmk6IENvbnZlcnQudXJpVG9QYXRoKGxvY2F0aW9uLnVyaSksXG4gICAgICBuYW1lOiBudWxsLFxuICAgICAgcmFuZ2U6IENvbnZlcnQubHNSYW5nZVRvQXRvbVJhbmdlKGxvY2F0aW9uLnJhbmdlKSxcbiAgICB9O1xuICB9XG5cbiAgLy8gUHVibGljOiBHZXQgYSBzeW1ib2wgbmFtZSBmcm9tIGEge1RleHRFZGl0b3J9IGZvciBhIHNwZWNpZmljIHtQb2ludH0gaW4gdGhlIGRvY3VtZW50LlxuICBwdWJsaWMgc3RhdGljIGdldFJlZmVyZW5jZWRTeW1ib2xOYW1lKFxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcbiAgICBwb2ludDogUG9pbnQsXG4gICAgcmVmZXJlbmNlczogYXRvbUlkZS5SZWZlcmVuY2VbXSxcbiAgKTogc3RyaW5nIHtcbiAgICBpZiAocmVmZXJlbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFJlZmVyZW5jZSA9IHJlZmVyZW5jZXMuZmluZCgocikgPT4gci5yYW5nZS5jb250YWluc1BvaW50KHBvaW50KSkgfHwgcmVmZXJlbmNlc1swXTtcbiAgICByZXR1cm4gZWRpdG9yLmdldEJ1ZmZlcigpLmdldFRleHRJblJhbmdlKGN1cnJlbnRSZWZlcmVuY2UucmFuZ2UpO1xuICB9XG59XG4iXX0=