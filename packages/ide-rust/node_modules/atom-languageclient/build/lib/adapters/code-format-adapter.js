"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
// Public: Adapts the language server protocol "textDocument/completion" to the
// Atom IDE UI Code-format package.
class CodeFormatAdapter {
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing either a documentFormattingProvider
    // or a documentRangeFormattingProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating this adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return (serverCapabilities.documentRangeFormattingProvider === true ||
            serverCapabilities.documentFormattingProvider === true);
    }
    // Public: Format text in the editor using the given language server connection and an optional range.
    // If the server does not support range formatting then range will be ignored and the entire document formatted.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will format the text.
    // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
    // * `editor` The Atom {TextEditor} containing the text that will be formatted.
    // * `range` The optional Atom {Range} containing the subset of the text to be formatted.
    //
    // Returns a {Promise} of an {Array} of {Object}s containing the AutoComplete+
    // suggestions to display.
    static format(connection, serverCapabilities, editor, range) {
        if (serverCapabilities.documentRangeFormattingProvider) {
            return CodeFormatAdapter.formatRange(connection, editor, range);
        }
        if (serverCapabilities.documentFormattingProvider) {
            return CodeFormatAdapter.formatDocument(connection, editor);
        }
        throw new Error('Can not format document, language server does not support it');
    }
    // Public: Format the entire document of an Atom {TextEditor} by using a given language server.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will format the text.
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    //
    // Returns a {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
    // to format the document.
    static formatDocument(connection, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            const edits = yield connection.documentFormatting(CodeFormatAdapter.createDocumentFormattingParams(editor));
            return convert_1.default.convertLsTextEdits(edits);
        });
    }
    // Public: Create {DocumentFormattingParams} to be sent to the language server when requesting an
    // entire document is formatted.
    //
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    //
    // Returns {DocumentFormattingParams} containing the identity of the text document as well as
    // options to be used in formatting the document such as tab size and tabs vs spaces.
    static createDocumentFormattingParams(editor) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            options: CodeFormatAdapter.getFormatOptions(editor),
        };
    }
    // Public: Format a range within an Atom {TextEditor} by using a given language server.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will format the text.
    // * `range` The Atom {Range} containing the range of text that should be formatted.
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    //
    // Returns a {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
    // to format the document.
    static formatRange(connection, editor, range) {
        return __awaiter(this, void 0, void 0, function* () {
            const edits = yield connection.documentRangeFormatting(CodeFormatAdapter.createDocumentRangeFormattingParams(editor, range));
            return convert_1.default.convertLsTextEdits(edits);
        });
    }
    // Public: Create {DocumentRangeFormattingParams} to be sent to the language server when requesting an
    // entire document is formatted.
    //
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    // * `range` The Atom {Range} containing the range of text that should be formatted.
    //
    // Returns {DocumentRangeFormattingParams} containing the identity of the text document, the
    // range of the text to be formatted as well as the options to be used in formatting the
    // document such as tab size and tabs vs spaces.
    static createDocumentRangeFormattingParams(editor, range) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            range: convert_1.default.atomRangeToLSRange(range),
            options: CodeFormatAdapter.getFormatOptions(editor),
        };
    }
    // Public: Create {DocumentRangeFormattingParams} to be sent to the language server when requesting an
    // entire document is formatted.
    //
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    // * `range` The Atom {Range} containing the range of document that should be formatted.
    //
    // Returns the {FormattingOptions} to be used containing the keys:
    //  * `tabSize` The number of spaces a tab represents.
    //  * `insertSpaces` {True} if spaces should be used, {False} for tab characters.
    static getFormatOptions(editor) {
        return {
            tabSize: editor.getTabLength(),
            insertSpaces: editor.getSoftTabs(),
        };
    }
}
exports.default = CodeFormatAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29kZS1mb3JtYXQtYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9jb2RlLWZvcm1hdC1hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFTQSx3Q0FBaUM7QUFFakMsK0VBQStFO0FBQy9FLG1DQUFtQztBQUNuQztJQUNFLGdGQUFnRjtJQUNoRix3RkFBd0Y7SUFDeEYsd0NBQXdDO0lBQ3hDLEVBQUU7SUFDRixzRkFBc0Y7SUFDdEYsRUFBRTtJQUNGLGdGQUFnRjtJQUNoRiw0QkFBNEI7SUFDckIsTUFBTSxDQUFDLFFBQVEsQ0FBQyxrQkFBc0M7UUFDM0QsTUFBTSxDQUFDLENBQ0wsa0JBQWtCLENBQUMsK0JBQStCLEtBQUssSUFBSTtZQUMzRCxrQkFBa0IsQ0FBQywwQkFBMEIsS0FBSyxJQUFJLENBQ3ZELENBQUM7SUFDSixDQUFDO0lBRUQsc0dBQXNHO0lBQ3RHLGdIQUFnSDtJQUNoSCxFQUFFO0lBQ0YsZ0dBQWdHO0lBQ2hHLDRGQUE0RjtJQUM1RiwrRUFBK0U7SUFDL0UseUZBQXlGO0lBQ3pGLEVBQUU7SUFDRiw4RUFBOEU7SUFDOUUsMEJBQTBCO0lBQ25CLE1BQU0sQ0FBQyxNQUFNLENBQ2xCLFVBQW9DLEVBQ3BDLGtCQUFzQyxFQUN0QyxNQUFrQixFQUNsQixLQUFZO1FBRVosRUFBRSxDQUFDLENBQUMsa0JBQWtCLENBQUMsK0JBQStCLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNsRSxDQUFDO1FBRUQsRUFBRSxDQUFDLENBQUMsa0JBQWtCLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxDQUFDO1lBQ2xELE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxjQUFjLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzlELENBQUM7UUFFRCxNQUFNLElBQUksS0FBSyxDQUFDLDhEQUE4RCxDQUFDLENBQUM7SUFDbEYsQ0FBQztJQUVELCtGQUErRjtJQUMvRixFQUFFO0lBQ0YsZ0dBQWdHO0lBQ2hHLDRFQUE0RTtJQUM1RSxFQUFFO0lBQ0YscUdBQXFHO0lBQ3JHLDBCQUEwQjtJQUNuQixNQUFNLENBQU8sY0FBYyxDQUNoQyxVQUFvQyxFQUNwQyxNQUFrQjs7WUFFbEIsTUFBTSxLQUFLLEdBQUcsTUFBTSxVQUFVLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLENBQUMsOEJBQThCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUM1RyxNQUFNLENBQUMsaUJBQU8sQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzQyxDQUFDO0tBQUE7SUFFRCxpR0FBaUc7SUFDakcsZ0NBQWdDO0lBQ2hDLEVBQUU7SUFDRiw0RUFBNEU7SUFDNUUsRUFBRTtJQUNGLDZGQUE2RjtJQUM3RixxRkFBcUY7SUFDOUUsTUFBTSxDQUFDLDhCQUE4QixDQUFDLE1BQWtCO1FBQzdELE1BQU0sQ0FBQztZQUNMLFlBQVksRUFBRSxpQkFBTyxDQUFDLDhCQUE4QixDQUFDLE1BQU0sQ0FBQztZQUM1RCxPQUFPLEVBQUUsaUJBQWlCLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDO1NBQ3BELENBQUM7SUFDSixDQUFDO0lBRUQsdUZBQXVGO0lBQ3ZGLEVBQUU7SUFDRixnR0FBZ0c7SUFDaEcsb0ZBQW9GO0lBQ3BGLDRFQUE0RTtJQUM1RSxFQUFFO0lBQ0YscUdBQXFHO0lBQ3JHLDBCQUEwQjtJQUNuQixNQUFNLENBQU8sV0FBVyxDQUM3QixVQUFvQyxFQUNwQyxNQUFrQixFQUNsQixLQUFZOztZQUVaLE1BQU0sS0FBSyxHQUFHLE1BQU0sVUFBVSxDQUFDLHVCQUF1QixDQUNwRCxpQkFBaUIsQ0FBQyxtQ0FBbUMsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQ3JFLENBQUM7WUFDRixNQUFNLENBQUMsaUJBQU8sQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzQyxDQUFDO0tBQUE7SUFFRCxzR0FBc0c7SUFDdEcsZ0NBQWdDO0lBQ2hDLEVBQUU7SUFDRiw0RUFBNEU7SUFDNUUsb0ZBQW9GO0lBQ3BGLEVBQUU7SUFDRiw0RkFBNEY7SUFDNUYsd0ZBQXdGO0lBQ3hGLGdEQUFnRDtJQUN6QyxNQUFNLENBQUMsbUNBQW1DLENBQy9DLE1BQWtCLEVBQ2xCLEtBQVk7UUFFWixNQUFNLENBQUM7WUFDTCxZQUFZLEVBQUUsaUJBQU8sQ0FBQyw4QkFBOEIsQ0FBQyxNQUFNLENBQUM7WUFDNUQsS0FBSyxFQUFFLGlCQUFPLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDO1lBQ3hDLE9BQU8sRUFBRSxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7U0FDcEQsQ0FBQztJQUNKLENBQUM7SUFFRCxzR0FBc0c7SUFDdEcsZ0NBQWdDO0lBQ2hDLEVBQUU7SUFDRiw0RUFBNEU7SUFDNUUsd0ZBQXdGO0lBQ3hGLEVBQUU7SUFDRixrRUFBa0U7SUFDbEUsc0RBQXNEO0lBQ3RELGlGQUFpRjtJQUMxRSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsTUFBa0I7UUFDL0MsTUFBTSxDQUFDO1lBQ0wsT0FBTyxFQUFFLE1BQU0sQ0FBQyxZQUFZLEVBQUU7WUFDOUIsWUFBWSxFQUFFLE1BQU0sQ0FBQyxXQUFXLEVBQUU7U0FDbkMsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQTlIRCxvQ0E4SEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gIERvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyxcbiAgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMsXG4gIEZvcm1hdHRpbmdPcHRpb25zLFxuICBTZXJ2ZXJDYXBhYmlsaXRpZXMsXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcbmltcG9ydCB7IFRleHRFZGl0b3IsIFJhbmdlIH0gZnJvbSAnYXRvbSc7XG5pbXBvcnQgKiBhcyBhdG9tSWRlIGZyb20gJ2F0b20taWRlJztcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xuXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHByb3RvY29sIFwidGV4dERvY3VtZW50L2NvbXBsZXRpb25cIiB0byB0aGVcbi8vIEF0b20gSURFIFVJIENvZGUtZm9ybWF0IHBhY2thZ2UuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2RlRm9ybWF0QWRhcHRlciB7XG4gIC8vIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyXG4gIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IGNvbnRhaW5pbmcgZWl0aGVyIGEgZG9jdW1lbnRGb3JtYXR0aW5nUHJvdmlkZXJcbiAgLy8gb3IgYSBkb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyLlxuICAvL1xuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGNvbnNpZGVyLlxuICAvL1xuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgdGhpcyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXG4gIHB1YmxpYyBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUHJvdmlkZXIgPT09IHRydWUgfHxcbiAgICAgIHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlciA9PT0gdHJ1ZVxuICAgICk7XG4gIH1cblxuICAvLyBQdWJsaWM6IEZvcm1hdCB0ZXh0IGluIHRoZSBlZGl0b3IgdXNpbmcgdGhlIGdpdmVuIGxhbmd1YWdlIHNlcnZlciBjb25uZWN0aW9uIGFuZCBhbiBvcHRpb25hbCByYW5nZS5cbiAgLy8gSWYgdGhlIHNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHJhbmdlIGZvcm1hdHRpbmcgdGhlbiByYW5nZSB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSBlbnRpcmUgZG9jdW1lbnQgZm9ybWF0dGVkLlxuICAvL1xuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGZvcm1hdCB0aGUgdGV4dC5cbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgdXNlZC5cbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgdGV4dCB0aGF0IHdpbGwgYmUgZm9ybWF0dGVkLlxuICAvLyAqIGByYW5nZWAgVGhlIG9wdGlvbmFsIEF0b20ge1JhbmdlfSBjb250YWluaW5nIHRoZSBzdWJzZXQgb2YgdGhlIHRleHQgdG8gYmUgZm9ybWF0dGVkLlxuICAvL1xuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IG9mIGFuIHtBcnJheX0gb2Yge09iamVjdH1zIGNvbnRhaW5pbmcgdGhlIEF1dG9Db21wbGV0ZStcbiAgLy8gc3VnZ2VzdGlvbnMgdG8gZGlzcGxheS5cbiAgcHVibGljIHN0YXRpYyBmb3JtYXQoXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxuICAgIHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzLFxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcbiAgICByYW5nZTogUmFuZ2UsXG4gICk6IFByb21pc2U8YXRvbUlkZS5UZXh0RWRpdFtdPiB7XG4gICAgaWYgKHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyKSB7XG4gICAgICByZXR1cm4gQ29kZUZvcm1hdEFkYXB0ZXIuZm9ybWF0UmFuZ2UoY29ubmVjdGlvbiwgZWRpdG9yLCByYW5nZSk7XG4gICAgfVxuXG4gICAgaWYgKHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlcikge1xuICAgICAgcmV0dXJuIENvZGVGb3JtYXRBZGFwdGVyLmZvcm1hdERvY3VtZW50KGNvbm5lY3Rpb24sIGVkaXRvcik7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGZvcm1hdCBkb2N1bWVudCwgbGFuZ3VhZ2Ugc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgaXQnKTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogRm9ybWF0IHRoZSBlbnRpcmUgZG9jdW1lbnQgb2YgYW4gQXRvbSB7VGV4dEVkaXRvcn0gYnkgdXNpbmcgYSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXG4gIC8vXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgZm9ybWF0IHRoZSB0ZXh0LlxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gb2YgYW4ge0FycmF5fSBvZiB7VGV4dEVkaXR9IG9iamVjdHMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0aGUgQXRvbSBUZXh0RWRpdG9yXG4gIC8vIHRvIGZvcm1hdCB0aGUgZG9jdW1lbnQuXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgZm9ybWF0RG9jdW1lbnQoXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcbiAgKTogUHJvbWlzZTxhdG9tSWRlLlRleHRFZGl0W10+IHtcbiAgICBjb25zdCBlZGl0cyA9IGF3YWl0IGNvbm5lY3Rpb24uZG9jdW1lbnRGb3JtYXR0aW5nKENvZGVGb3JtYXRBZGFwdGVyLmNyZWF0ZURvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyhlZGl0b3IpKTtcbiAgICByZXR1cm4gQ29udmVydC5jb252ZXJ0THNUZXh0RWRpdHMoZWRpdHMpO1xuICB9XG5cbiAgLy8gUHVibGljOiBDcmVhdGUge0RvY3VtZW50Rm9ybWF0dGluZ1BhcmFtc30gdG8gYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHdoZW4gcmVxdWVzdGluZyBhblxuICAvLyBlbnRpcmUgZG9jdW1lbnQgaXMgZm9ybWF0dGVkLlxuICAvL1xuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXG4gIC8vXG4gIC8vIFJldHVybnMge0RvY3VtZW50Rm9ybWF0dGluZ1BhcmFtc30gY29udGFpbmluZyB0aGUgaWRlbnRpdHkgb2YgdGhlIHRleHQgZG9jdW1lbnQgYXMgd2VsbCBhc1xuICAvLyBvcHRpb25zIHRvIGJlIHVzZWQgaW4gZm9ybWF0dGluZyB0aGUgZG9jdW1lbnQgc3VjaCBhcyB0YWIgc2l6ZSBhbmQgdGFicyB2cyBzcGFjZXMuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlRG9jdW1lbnRGb3JtYXR0aW5nUGFyYW1zKGVkaXRvcjogVGV4dEVkaXRvcik6IERvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHREb2N1bWVudDogQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudElkZW50aWZpZXIoZWRpdG9yKSxcbiAgICAgIG9wdGlvbnM6IENvZGVGb3JtYXRBZGFwdGVyLmdldEZvcm1hdE9wdGlvbnMoZWRpdG9yKSxcbiAgICB9O1xuICB9XG5cbiAgLy8gUHVibGljOiBGb3JtYXQgYSByYW5nZSB3aXRoaW4gYW4gQXRvbSB7VGV4dEVkaXRvcn0gYnkgdXNpbmcgYSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXG4gIC8vXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgZm9ybWF0IHRoZSB0ZXh0LlxuICAvLyAqIGByYW5nZWAgVGhlIEF0b20ge1JhbmdlfSBjb250YWluaW5nIHRoZSByYW5nZSBvZiB0ZXh0IHRoYXQgc2hvdWxkIGJlIGZvcm1hdHRlZC5cbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgZG9jdW1lbnQgdG8gYmUgZm9ybWF0dGVkLlxuICAvL1xuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IG9mIGFuIHtBcnJheX0gb2Yge1RleHRFZGl0fSBvYmplY3RzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIEF0b20gVGV4dEVkaXRvclxuICAvLyB0byBmb3JtYXQgdGhlIGRvY3VtZW50LlxuICBwdWJsaWMgc3RhdGljIGFzeW5jIGZvcm1hdFJhbmdlKFxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXG4gICAgcmFuZ2U6IFJhbmdlLFxuICApOiBQcm9taXNlPGF0b21JZGUuVGV4dEVkaXRbXT4ge1xuICAgIGNvbnN0IGVkaXRzID0gYXdhaXQgY29ubmVjdGlvbi5kb2N1bWVudFJhbmdlRm9ybWF0dGluZyhcbiAgICAgIENvZGVGb3JtYXRBZGFwdGVyLmNyZWF0ZURvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zKGVkaXRvciwgcmFuZ2UpLFxuICAgICk7XG4gICAgcmV0dXJuIENvbnZlcnQuY29udmVydExzVGV4dEVkaXRzKGVkaXRzKTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ3JlYXRlIHtEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtc30gdG8gYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHdoZW4gcmVxdWVzdGluZyBhblxuICAvLyBlbnRpcmUgZG9jdW1lbnQgaXMgZm9ybWF0dGVkLlxuICAvL1xuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXG4gIC8vICogYHJhbmdlYCBUaGUgQXRvbSB7UmFuZ2V9IGNvbnRhaW5pbmcgdGhlIHJhbmdlIG9mIHRleHQgdGhhdCBzaG91bGQgYmUgZm9ybWF0dGVkLlxuICAvL1xuICAvLyBSZXR1cm5zIHtEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtc30gY29udGFpbmluZyB0aGUgaWRlbnRpdHkgb2YgdGhlIHRleHQgZG9jdW1lbnQsIHRoZVxuICAvLyByYW5nZSBvZiB0aGUgdGV4dCB0byBiZSBmb3JtYXR0ZWQgYXMgd2VsbCBhcyB0aGUgb3B0aW9ucyB0byBiZSB1c2VkIGluIGZvcm1hdHRpbmcgdGhlXG4gIC8vIGRvY3VtZW50IHN1Y2ggYXMgdGFiIHNpemUgYW5kIHRhYnMgdnMgc3BhY2VzLlxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZURvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zKFxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcbiAgICByYW5nZTogUmFuZ2UsXG4gICk6IERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dERvY3VtZW50OiBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihlZGl0b3IpLFxuICAgICAgcmFuZ2U6IENvbnZlcnQuYXRvbVJhbmdlVG9MU1JhbmdlKHJhbmdlKSxcbiAgICAgIG9wdGlvbnM6IENvZGVGb3JtYXRBZGFwdGVyLmdldEZvcm1hdE9wdGlvbnMoZWRpdG9yKSxcbiAgICB9O1xuICB9XG5cbiAgLy8gUHVibGljOiBDcmVhdGUge0RvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zfSB0byBiZSBzZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgd2hlbiByZXF1ZXN0aW5nIGFuXG4gIC8vIGVudGlyZSBkb2N1bWVudCBpcyBmb3JtYXR0ZWQuXG4gIC8vXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIGRvY3VtZW50IHRvIGJlIGZvcm1hdHRlZC5cbiAgLy8gKiBgcmFuZ2VgIFRoZSBBdG9tIHtSYW5nZX0gY29udGFpbmluZyB0aGUgcmFuZ2Ugb2YgZG9jdW1lbnQgdGhhdCBzaG91bGQgYmUgZm9ybWF0dGVkLlxuICAvL1xuICAvLyBSZXR1cm5zIHRoZSB7Rm9ybWF0dGluZ09wdGlvbnN9IHRvIGJlIHVzZWQgY29udGFpbmluZyB0aGUga2V5czpcbiAgLy8gICogYHRhYlNpemVgIFRoZSBudW1iZXIgb2Ygc3BhY2VzIGEgdGFiIHJlcHJlc2VudHMuXG4gIC8vICAqIGBpbnNlcnRTcGFjZXNgIHtUcnVlfSBpZiBzcGFjZXMgc2hvdWxkIGJlIHVzZWQsIHtGYWxzZX0gZm9yIHRhYiBjaGFyYWN0ZXJzLlxuICBwdWJsaWMgc3RhdGljIGdldEZvcm1hdE9wdGlvbnMoZWRpdG9yOiBUZXh0RWRpdG9yKTogRm9ybWF0dGluZ09wdGlvbnMge1xuICAgIHJldHVybiB7XG4gICAgICB0YWJTaXplOiBlZGl0b3IuZ2V0VGFiTGVuZ3RoKCksXG4gICAgICBpbnNlcnRTcGFjZXM6IGVkaXRvci5nZXRTb2Z0VGFicygpLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==