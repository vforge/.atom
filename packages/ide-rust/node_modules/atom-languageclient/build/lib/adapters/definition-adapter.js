"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
const utils_1 = require("../utils");
const atom_1 = require("atom");
// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
class DefinitionAdapter {
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing a definitionProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return serverCapabilities.definitionProvider === true;
    }
    // Public: Get the definitions for a symbol at a given {Point} within a
    // {TextEditor} including optionally highlighting all other references
    // within the document if the langauge server also supports highlighting.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will provide definitions and highlights.
    // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
    // * `languageName` The name of the programming language.
    // * `editor` The Atom {TextEditor} containing the symbol and potential highlights.
    // * `point` The Atom {Point} containing the position of the text that represents the symbol
    //           for which the definition and highlights should be provided.
    //
    // Returns a {Promise} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    getDefinition(connection, serverCapabilities, languageName, editor, point) {
        return __awaiter(this, void 0, void 0, function* () {
            const documentPositionParams = convert_1.default.editorToTextDocumentPositionParams(editor, point);
            const definitionLocations = DefinitionAdapter.normalizeLocations(yield connection.gotoDefinition(documentPositionParams));
            if (definitionLocations == null || definitionLocations.length === 0) {
                return null;
            }
            let queryRange;
            if (serverCapabilities.documentHighlightProvider) {
                const highlights = yield connection.documentHighlight(documentPositionParams);
                if (highlights != null && highlights.length > 0) {
                    queryRange = highlights.map((h) => convert_1.default.lsRangeToAtomRange(h.range));
                }
            }
            return {
                queryRange: queryRange || [utils_1.default.getWordAtPosition(editor, point)],
                definitions: DefinitionAdapter.convertLocationsToDefinitions(definitionLocations, languageName),
            };
        });
    }
    // Public: Normalize the locations so a single {Location} becomes an {Array} of just
    // one. The language server protocol return either as the protocol evolved between v1 and v2.
    //
    // * `locationResult` either a single {Location} object or an {Array} of {Locations}
    //
    // Returns an {Array} of {Location}s or {null} if the locationResult was null.
    static normalizeLocations(locationResult) {
        if (locationResult == null) {
            return null;
        }
        return (Array.isArray(locationResult) ? locationResult : [locationResult]).filter((d) => d.range.start != null);
    }
    // Public: Convert an {Array} of {Location} objects into an Array of {Definition}s.
    //
    // * `locations` An {Array} of {Location} objects to be converted.
    // * `languageName` The name of the language these objects are written in.
    //
    // Returns an {Array} of {Definition}s that represented the converted {Location}s.
    static convertLocationsToDefinitions(locations, languageName) {
        return locations.map((d) => ({
            path: convert_1.default.uriToPath(d.uri),
            position: convert_1.default.positionToPoint(d.range.start),
            range: atom_1.Range.fromObject(convert_1.default.lsRangeToAtomRange(d.range)),
            language: languageName,
        }));
    }
}
exports.default = DefinitionAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmaW5pdGlvbi1hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2FkYXB0ZXJzL2RlZmluaXRpb24tYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0Esd0NBQWlDO0FBQ2pDLG9DQUE2QjtBQUM3QiwrQkFBZ0Q7QUFHaEQsZ0VBQWdFO0FBQ2hFLHdFQUF3RTtBQUN4RTtJQUNFLGdGQUFnRjtJQUNoRiwwRUFBMEU7SUFDMUUsRUFBRTtJQUNGLHNGQUFzRjtJQUN0RixFQUFFO0lBQ0YsMkVBQTJFO0lBQzNFLDRCQUE0QjtJQUNyQixNQUFNLENBQUMsUUFBUSxDQUFDLGtCQUFzQztRQUMzRCxNQUFNLENBQUMsa0JBQWtCLENBQUMsa0JBQWtCLEtBQUssSUFBSSxDQUFDO0lBQ3hELENBQUM7SUFFRCx1RUFBdUU7SUFDdkUsc0VBQXNFO0lBQ3RFLHlFQUF5RTtJQUN6RSxFQUFFO0lBQ0YsbUhBQW1IO0lBQ25ILDRGQUE0RjtJQUM1Rix5REFBeUQ7SUFDekQsbUZBQW1GO0lBQ25GLDRGQUE0RjtJQUM1Rix3RUFBd0U7SUFDeEUsRUFBRTtJQUNGLDJFQUEyRTtJQUMzRSw0QkFBNEI7SUFDZixhQUFhLENBQ3hCLFVBQW9DLEVBQ3BDLGtCQUFzQyxFQUN0QyxZQUFvQixFQUNwQixNQUFrQixFQUNsQixLQUFZOztZQUVaLE1BQU0sc0JBQXNCLEdBQUcsaUJBQU8sQ0FBQyxrQ0FBa0MsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDekYsTUFBTSxtQkFBbUIsR0FBRyxpQkFBaUIsQ0FBQyxrQkFBa0IsQ0FDOUQsTUFBTSxVQUFVLENBQUMsY0FBYyxDQUFDLHNCQUFzQixDQUFDLENBQ3hELENBQUM7WUFDRixFQUFFLENBQUMsQ0FBQyxtQkFBbUIsSUFBSSxJQUFJLElBQUksbUJBQW1CLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3BFLE1BQU0sQ0FBQyxJQUFJLENBQUM7WUFDZCxDQUFDO1lBRUQsSUFBSSxVQUFVLENBQUM7WUFDZixFQUFFLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUM7Z0JBQ2pELE1BQU0sVUFBVSxHQUFHLE1BQU0sVUFBVSxDQUFDLGlCQUFpQixDQUFDLHNCQUFzQixDQUFDLENBQUM7Z0JBQzlFLEVBQUUsQ0FBQyxDQUFDLFVBQVUsSUFBSSxJQUFJLElBQUksVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNoRCxVQUFVLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsaUJBQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDMUUsQ0FBQztZQUNILENBQUM7WUFFRCxNQUFNLENBQUM7Z0JBQ0wsVUFBVSxFQUFFLFVBQVUsSUFBSSxDQUFDLGVBQUssQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ2xFLFdBQVcsRUFBRSxpQkFBaUIsQ0FBQyw2QkFBNkIsQ0FBQyxtQkFBbUIsRUFBRSxZQUFZLENBQUM7YUFDaEcsQ0FBQztRQUNKLENBQUM7S0FBQTtJQUVELG9GQUFvRjtJQUNwRiw2RkFBNkY7SUFDN0YsRUFBRTtJQUNGLG9GQUFvRjtJQUNwRixFQUFFO0lBQ0YsOEVBQThFO0lBQ3ZFLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxjQUFxQztRQUNwRSxFQUFFLENBQUMsQ0FBQyxjQUFjLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUMzQixNQUFNLENBQUMsSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUNELE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUM7SUFDbEgsQ0FBQztJQUVELG1GQUFtRjtJQUNuRixFQUFFO0lBQ0Ysa0VBQWtFO0lBQ2xFLDBFQUEwRTtJQUMxRSxFQUFFO0lBQ0Ysa0ZBQWtGO0lBQzNFLE1BQU0sQ0FBQyw2QkFBNkIsQ0FBQyxTQUFxQixFQUFFLFlBQW9CO1FBQ3JGLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzNCLElBQUksRUFBRSxpQkFBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1lBQzlCLFFBQVEsRUFBRSxpQkFBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztZQUNoRCxLQUFLLEVBQUUsWUFBSyxDQUFDLFVBQVUsQ0FBQyxpQkFBTyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM1RCxRQUFRLEVBQUUsWUFBWTtTQUN2QixDQUFDLENBQUMsQ0FBQztJQUNOLENBQUM7Q0FDRjtBQWpGRCxvQ0FpRkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIExvY2F0aW9uLCBTZXJ2ZXJDYXBhYmlsaXRpZXMgfSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBQb2ludCwgVGV4dEVkaXRvciwgUmFuZ2UgfSBmcm9tICdhdG9tJztcbmltcG9ydCAqIGFzIGF0b21JZGUgZnJvbSAnYXRvbS1pZGUnO1xuXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGRlZmluaXRpb24gcHJvdmlkZXIgdG8gdGhlXG4vLyBBdG9tIElERSBVSSBEZWZpbml0aW9ucyBwYWNrYWdlIGZvciAnR28gVG8gRGVmaW5pdGlvbicgZnVuY3Rpb25hbGl0eS5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmluaXRpb25BZGFwdGVyIHtcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBhIGRlZmluaXRpb25Qcm92aWRlci5cbiAgLy9cbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cbiAgcHVibGljIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMuZGVmaW5pdGlvblByb3ZpZGVyID09PSB0cnVlO1xuICB9XG5cbiAgLy8gUHVibGljOiBHZXQgdGhlIGRlZmluaXRpb25zIGZvciBhIHN5bWJvbCBhdCBhIGdpdmVuIHtQb2ludH0gd2l0aGluIGFcbiAgLy8ge1RleHRFZGl0b3J9IGluY2x1ZGluZyBvcHRpb25hbGx5IGhpZ2hsaWdodGluZyBhbGwgb3RoZXIgcmVmZXJlbmNlc1xuICAvLyB3aXRoaW4gdGhlIGRvY3VtZW50IGlmIHRoZSBsYW5nYXVnZSBzZXJ2ZXIgYWxzbyBzdXBwb3J0cyBoaWdobGlnaHRpbmcuXG4gIC8vXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgcHJvdmlkZSBkZWZpbml0aW9ucyBhbmQgaGlnaGxpZ2h0cy5cbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgdXNlZC5cbiAgLy8gKiBgbGFuZ3VhZ2VOYW1lYCBUaGUgbmFtZSBvZiB0aGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UuXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIHN5bWJvbCBhbmQgcG90ZW50aWFsIGhpZ2hsaWdodHMuXG4gIC8vICogYHBvaW50YCBUaGUgQXRvbSB7UG9pbnR9IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSB0ZXh0IHRoYXQgcmVwcmVzZW50cyB0aGUgc3ltYm9sXG4gIC8vICAgICAgICAgICBmb3Igd2hpY2ggdGhlIGRlZmluaXRpb24gYW5kIGhpZ2hsaWdodHMgc2hvdWxkIGJlIHByb3ZpZGVkLlxuICAvL1xuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxuICBwdWJsaWMgYXN5bmMgZ2V0RGVmaW5pdGlvbihcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gICAgc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMsXG4gICAgbGFuZ3VhZ2VOYW1lOiBzdHJpbmcsXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxuICAgIHBvaW50OiBQb2ludCxcbiAgKTogUHJvbWlzZTxhdG9tSWRlLkRlZmluaXRpb25RdWVyeVJlc3VsdCB8IG51bGw+IHtcbiAgICBjb25zdCBkb2N1bWVudFBvc2l0aW9uUGFyYW1zID0gQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKGVkaXRvciwgcG9pbnQpO1xuICAgIGNvbnN0IGRlZmluaXRpb25Mb2NhdGlvbnMgPSBEZWZpbml0aW9uQWRhcHRlci5ub3JtYWxpemVMb2NhdGlvbnMoXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmdvdG9EZWZpbml0aW9uKGRvY3VtZW50UG9zaXRpb25QYXJhbXMpLFxuICAgICk7XG4gICAgaWYgKGRlZmluaXRpb25Mb2NhdGlvbnMgPT0gbnVsbCB8fCBkZWZpbml0aW9uTG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHF1ZXJ5UmFuZ2U7XG4gICAgaWYgKHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudEhpZ2hsaWdodFByb3ZpZGVyKSB7XG4gICAgICBjb25zdCBoaWdobGlnaHRzID0gYXdhaXQgY29ubmVjdGlvbi5kb2N1bWVudEhpZ2hsaWdodChkb2N1bWVudFBvc2l0aW9uUGFyYW1zKTtcbiAgICAgIGlmIChoaWdobGlnaHRzICE9IG51bGwgJiYgaGlnaGxpZ2h0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHF1ZXJ5UmFuZ2UgPSBoaWdobGlnaHRzLm1hcCgoaCkgPT4gQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UoaC5yYW5nZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBxdWVyeVJhbmdlOiBxdWVyeVJhbmdlIHx8IFtVdGlscy5nZXRXb3JkQXRQb3NpdGlvbihlZGl0b3IsIHBvaW50KV0sXG4gICAgICBkZWZpbml0aW9uczogRGVmaW5pdGlvbkFkYXB0ZXIuY29udmVydExvY2F0aW9uc1RvRGVmaW5pdGlvbnMoZGVmaW5pdGlvbkxvY2F0aW9ucywgbGFuZ3VhZ2VOYW1lKSxcbiAgICB9O1xuICB9XG5cbiAgLy8gUHVibGljOiBOb3JtYWxpemUgdGhlIGxvY2F0aW9ucyBzbyBhIHNpbmdsZSB7TG9jYXRpb259IGJlY29tZXMgYW4ge0FycmF5fSBvZiBqdXN0XG4gIC8vIG9uZS4gVGhlIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCByZXR1cm4gZWl0aGVyIGFzIHRoZSBwcm90b2NvbCBldm9sdmVkIGJldHdlZW4gdjEgYW5kIHYyLlxuICAvL1xuICAvLyAqIGBsb2NhdGlvblJlc3VsdGAgZWl0aGVyIGEgc2luZ2xlIHtMb2NhdGlvbn0gb2JqZWN0IG9yIGFuIHtBcnJheX0gb2Yge0xvY2F0aW9uc31cbiAgLy9cbiAgLy8gUmV0dXJucyBhbiB7QXJyYXl9IG9mIHtMb2NhdGlvbn1zIG9yIHtudWxsfSBpZiB0aGUgbG9jYXRpb25SZXN1bHQgd2FzIG51bGwuXG4gIHB1YmxpYyBzdGF0aWMgbm9ybWFsaXplTG9jYXRpb25zKGxvY2F0aW9uUmVzdWx0OiBMb2NhdGlvbiB8IExvY2F0aW9uW10pOiBMb2NhdGlvbltdIHwgbnVsbCB7XG4gICAgaWYgKGxvY2F0aW9uUmVzdWx0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkobG9jYXRpb25SZXN1bHQpID8gbG9jYXRpb25SZXN1bHQgOiBbbG9jYXRpb25SZXN1bHRdKS5maWx0ZXIoKGQpID0+IGQucmFuZ2Uuc3RhcnQgIT0gbnVsbCk7XG4gIH1cblxuICAvLyBQdWJsaWM6IENvbnZlcnQgYW4ge0FycmF5fSBvZiB7TG9jYXRpb259IG9iamVjdHMgaW50byBhbiBBcnJheSBvZiB7RGVmaW5pdGlvbn1zLlxuICAvL1xuICAvLyAqIGBsb2NhdGlvbnNgIEFuIHtBcnJheX0gb2Yge0xvY2F0aW9ufSBvYmplY3RzIHRvIGJlIGNvbnZlcnRlZC5cbiAgLy8gKiBgbGFuZ3VhZ2VOYW1lYCBUaGUgbmFtZSBvZiB0aGUgbGFuZ3VhZ2UgdGhlc2Ugb2JqZWN0cyBhcmUgd3JpdHRlbiBpbi5cbiAgLy9cbiAgLy8gUmV0dXJucyBhbiB7QXJyYXl9IG9mIHtEZWZpbml0aW9ufXMgdGhhdCByZXByZXNlbnRlZCB0aGUgY29udmVydGVkIHtMb2NhdGlvbn1zLlxuICBwdWJsaWMgc3RhdGljIGNvbnZlcnRMb2NhdGlvbnNUb0RlZmluaXRpb25zKGxvY2F0aW9uczogTG9jYXRpb25bXSwgbGFuZ3VhZ2VOYW1lOiBzdHJpbmcpOiBhdG9tSWRlLkRlZmluaXRpb25bXSB7XG4gICAgcmV0dXJuIGxvY2F0aW9ucy5tYXAoKGQpID0+ICh7XG4gICAgICBwYXRoOiBDb252ZXJ0LnVyaVRvUGF0aChkLnVyaSksXG4gICAgICBwb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoZC5yYW5nZS5zdGFydCksXG4gICAgICByYW5nZTogUmFuZ2UuZnJvbU9iamVjdChDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZShkLnJhbmdlKSksXG4gICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VOYW1lLFxuICAgIH0pKTtcbiAgfVxufVxuIl19