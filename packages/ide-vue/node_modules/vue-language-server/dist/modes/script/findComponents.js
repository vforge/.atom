"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
function findComponents(service, fileFsPath) {
    const program = service.getProgram();
    const sourceFile = program.getSourceFile(fileFsPath);
    const exportStmt = sourceFile.statements.filter(st => st.kind === ts.SyntaxKind.ExportAssignment);
    if (exportStmt.length === 0) {
        return [];
    }
    // vls will create synthetic __vueEditorBridge({ ... })
    const exportCall = exportStmt[0].expression;
    if (exportCall.kind !== ts.SyntaxKind.CallExpression) {
        return [];
    }
    const comp = exportCall.arguments[0];
    const checker = program.getTypeChecker();
    const compType = checker.getTypeAtLocation(comp);
    const childComps = getPropertyTypeOfType(compType, 'components', checker);
    if (!childComps) {
        return [];
    }
    return checker.getPropertiesOfType(childComps).map(s => getCompInfo(s, checker));
}
exports.findComponents = findComponents;
function getCompInfo(symbol, checker) {
    const compType = getSymbolType(symbol, checker);
    const info = {
        name: hyphenate(symbol.name),
    };
    if (!compType) {
        return info;
    }
    if (compType.symbol && compType.symbol.declarations) {
        const declaration = compType.symbol.declarations[0];
        if (declaration) {
            const fileName = declaration.getSourceFile().fileName;
            info.definition = [{
                    uri: vscode_uri_1.default.file(fileName).toString(),
                    range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0)
                }];
        }
    }
    const arrayProps = getArrayProps(compType, checker);
    if (arrayProps) {
        info.props = arrayProps;
        return info;
    }
    const props = getPropertyTypeOfType(compType, 'props', checker);
    if (!props) {
        return info;
    }
    info.props = checker.getPropertiesOfType(props).map(s => {
        return {
            name: hyphenate(s.name),
            doc: getPropTypeDeclaration(s, checker)
        };
    });
    return info;
}
function getPropTypeDeclaration(prop, checker) {
    if (!prop.valueDeclaration) {
        return '';
    }
    const declaration = prop.valueDeclaration.getChildAt(2);
    if (!declaration) {
        return '';
    }
    if (declaration.kind === ts.SyntaxKind.ObjectLiteralExpression) {
        const text = [];
        declaration.forEachChild(n => {
            text.push(n.getText());
        });
        return text.join('\n');
    }
    return declaration.getText();
}
function getArrayProps(compType, checker) {
    const propSymbol = checker.getPropertyOfType(compType, 'props');
    if (!propSymbol || !propSymbol.valueDeclaration) {
        return undefined;
    }
    const propDef = propSymbol.valueDeclaration.getChildAt(2);
    if (!propDef || propDef.kind !== ts.SyntaxKind.ArrayLiteralExpression) {
        return undefined;
    }
    const propArray = propDef;
    return propArray.elements
        .filter(e => e.kind === ts.SyntaxKind.StringLiteral)
        .map((e) => ({ name: hyphenate(e.text) }));
}
function getPropertyTypeOfType(tpe, property, checker) {
    const propSymbol = checker.getPropertyOfType(tpe, property);
    return getSymbolType(propSymbol, checker);
}
function getSymbolType(symbol, checker) {
    if (!symbol || !symbol.valueDeclaration) {
        return undefined;
    }
    return checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
}
const hyphenateRE = /\B([A-Z])/g;
function hyphenate(word) {
    return word.replace(hyphenateRE, '-$1').toLowerCase();
}
//# sourceMappingURL=findComponents.js.map