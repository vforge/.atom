/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Joshua Pinkney. All rights reserved.
 *  Copyright (c) Adam Voss. All rights reserved.
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
const vscode_languageserver_1 = require("vscode-languageserver");
const request_light_1 = require("request-light");
const path = require("path");
const fs = require("fs");
const uri_1 = require("./languageService/utils/uri");
const URL = require("url");
const Strings = require("./languageService/utils/strings");
const vscode_yaml_languageservice_1 = require("vscode-yaml-languageservice");
const languageModelCache_1 = require("./languageModelCache");
const arrUtils_1 = require("./languageService/utils/arrUtils");
const yaml_ast_parser_1 = require("yaml-ast-parser");
const yamlLanguageService_1 = require("./languageService/yamlLanguageService");
var minimatch = require("minimatch");
const nls = require("vscode-nls");
const jsonSchemaService_1 = require("./languageService/services/jsonSchemaService");
nls.config(process.env['VSCODE_NLS_CONFIG']);
var SchemaAssociationNotification;
(function (SchemaAssociationNotification) {
    SchemaAssociationNotification.type = new vscode_languageserver_1.NotificationType('json/schemaAssociations');
})(SchemaAssociationNotification || (SchemaAssociationNotification = {}));
var VSCodeContentRequest;
(function (VSCodeContentRequest) {
    VSCodeContentRequest.type = new vscode_languageserver_1.RequestType('vscode/content');
})(VSCodeContentRequest || (VSCodeContentRequest = {}));
var ColorSymbolRequest;
(function (ColorSymbolRequest) {
    ColorSymbolRequest.type = new vscode_languageserver_1.RequestType('json/colorSymbols');
})(ColorSymbolRequest || (ColorSymbolRequest = {}));
// Create a connection for the server.
let connection = null;
if (process.argv.indexOf('--stdio') == -1) {
    connection = vscode_languageserver_1.createConnection(new vscode_languageserver_1.IPCMessageReader(process), new vscode_languageserver_1.IPCMessageWriter(process));
}
else {
    connection = vscode_languageserver_1.createConnection();
}
console.log = connection.console.log.bind(connection.console);
console.error = connection.console.error.bind(connection.console);
// Create a simple text document manager. The text document manager
// supports full document sync only
let documents = new vscode_languageserver_1.TextDocuments();
// Make the text document manager listen on the connection
// for open, change and close text document events
documents.listen(connection);
let clientSnippetSupport = false;
let clientDynamicRegisterSupport = false;
// After the server has started the client sends an initilize request. The server receives
// in the passed params the rootPath of the workspace plus the client capabilities.
let workspaceRoot;
connection.onInitialize((params) => {
    workspaceRoot = uri_1.default.parse(params.rootPath);
    function hasClientCapability(...keys) {
        let c = params.capabilities;
        for (let i = 0; c && i < keys.length; i++) {
            c = c[keys[i]];
        }
        return !!c;
    }
    //clientSnippetSupport = hasClientCapability('textDocument', 'completion', 'completionItem', 'snippetSupport');
    //clientDynamicRegisterSupport = hasClientCapability('workspace', 'symbol', 'dynamicRegistration');
    return {
        capabilities: {
            // Tell the client that the server works in FULL text document sync mode
            textDocumentSync: documents.syncKind,
            // Disabled because too JSON centric
            completionProvider: { resolveProvider: true },
            hoverProvider: true,
            documentSymbolProvider: true,
            documentFormattingProvider: false
        }
    };
});
let workspaceContext = {
    resolveRelativePath: (relativePath, resource) => {
        return URL.resolve(resource, relativePath);
    }
};
let schemaRequestService = (uri) => {
    if (Strings.startsWith(uri, 'file://')) {
        let fsPath = uri_1.default.parse(uri).fsPath;
        return new Promise((c, e) => {
            fs.readFile(fsPath, 'UTF-8', (err, result) => {
                err ? e('') : c(result.toString());
            });
        });
    }
    else if (Strings.startsWith(uri, 'vscode://')) {
        return connection.sendRequest(VSCodeContentRequest.type, uri).then(responseText => {
            return responseText;
        }, error => {
            return error.message;
        });
    }
    if (uri.indexOf('//schema.management.azure.com/') !== -1) {
        connection.telemetry.logEvent({
            key: 'json.schema',
            value: {
                schemaURL: uri
            }
        });
    }
    let headers = { 'Accept-Encoding': 'gzip, deflate' };
    return request_light_1.xhr({ url: uri, followRedirects: 5, headers }).then(response => {
        return response.responseText;
    }, (error) => {
        return Promise.reject(error.responseText || request_light_1.getErrorStatusDescription(error.status) || error.toString());
    });
};
// create the YAML language service
let languageService = vscode_yaml_languageservice_1.getLanguageService({
    schemaRequestService,
    workspaceContext,
    contributions: []
});
let KUBERNETES_SCHEMA_URL = "http://central.maven.org/maven2/io/fabric8/kubernetes-model/1.1.4/kubernetes-model-1.1.4-schema.json";
let customLanguageService = yamlLanguageService_1.getLanguageService(schemaRequestService, workspaceContext);
let yamlConfigurationSettings = void 0;
let schemaAssociations = void 0;
let formatterRegistration = null;
let specificValidatorPaths = [];
let schemaConfigurationSettings = [];
// The settings have changed. Is send on server activation as well.
connection.onDidChangeConfiguration((change) => {
    var settings = change.settings;
    request_light_1.configure(settings.http && settings.http.proxy, settings.http && settings.http.proxyStrictSSL);
    specificValidatorPaths = [];
    yamlConfigurationSettings = settings.yaml && settings.yaml.schemas;
    schemaConfigurationSettings = [];
    for (let url in yamlConfigurationSettings) {
        let globPattern = yamlConfigurationSettings[url];
        let schemaObj = {
            "fileMatch": Array.isArray(globPattern) ? globPattern : [globPattern],
            "url": url
        };
        schemaConfigurationSettings.push(schemaObj);
    }
    updateConfiguration();
    // dynamically enable & disable the formatter
    if (clientDynamicRegisterSupport) {
        let enableFormatter = settings && settings.yaml && settings.yaml.format && settings.yaml.format.enable;
        if (enableFormatter) {
            if (!formatterRegistration) {
                formatterRegistration = connection.client.register(vscode_languageserver_1.DocumentFormattingRequest.type, { documentSelector: [{ language: 'yaml' }] });
            }
        }
        else if (formatterRegistration) {
            formatterRegistration.then(r => r.dispose());
            formatterRegistration = null;
        }
    }
});
// The jsonValidation extension configuration has changed
connection.onNotification(SchemaAssociationNotification.type, associations => {
    schemaAssociations = associations;
    specificValidatorPaths = [];
    updateConfiguration();
});
function updateConfiguration() {
    let languageSettings = {
        validate: true,
        schemas: []
    };
    if (schemaAssociations) {
        for (var pattern in schemaAssociations) {
            let association = schemaAssociations[pattern];
            if (Array.isArray(association)) {
                association.forEach(uri => {
                    languageSettings = configureSchemas(uri, [pattern], null);
                });
            }
        }
    }
    if (schemaConfigurationSettings) {
        schemaConfigurationSettings.forEach(schema => {
            let uri = schema.url;
            if (!uri && schema.schema) {
                uri = schema.schema.id;
            }
            if (!uri && schema.fileMatch) {
                uri = 'vscode://schemas/custom/' + encodeURIComponent(schema.fileMatch.join('&'));
            }
            if (uri) {
                if (uri[0] === '.' && workspaceRoot) {
                    // workspace relative path
                    uri = uri_1.default.file(path.normalize(path.join(workspaceRoot.fsPath, uri))).toString();
                }
                languageSettings = configureSchemas(uri, schema.fileMatch, schema.schema);
            }
        });
    }
    languageService.configure(languageSettings);
    customLanguageService.configure(languageSettings);
    // Revalidate any open text documents
    documents.all().forEach(triggerValidation);
}
function configureSchemas(uri, fileMatch, schema) {
    let languageSettings = {
        validate: true,
        schemas: []
    };
    if (uri.toLowerCase().trim() === "kedge") {
    }
    else if (uri.toLowerCase().trim() === "kubernetes") {
        uri = KUBERNETES_SCHEMA_URL;
    }
    if (schema === null) {
        languageSettings.schemas.push({ uri, fileMatch: fileMatch });
    }
    else {
        languageSettings.schemas.push({ uri, fileMatch: fileMatch, schema: schema });
    }
    if (fileMatch.constructor === Array && uri === KUBERNETES_SCHEMA_URL) {
        fileMatch.forEach((url) => {
            specificValidatorPaths.push(url);
        });
    }
    else if (uri === KUBERNETES_SCHEMA_URL) {
        specificValidatorPaths.push(fileMatch);
    }
    return languageSettings;
}
// The content of a text document has changed. This event is emitted
// when the text document first opened or when its content has changed.
documents.onDidChangeContent((change) => {
    triggerValidation(change.document);
});
// a document has closed: clear all diagnostics
documents.onDidClose(event => {
    cleanPendingValidation(event.document);
    connection.sendDiagnostics({ uri: event.document.uri, diagnostics: [] });
});
let pendingValidationRequests = {};
const validationDelayMs = 200;
function cleanPendingValidation(textDocument) {
    let request = pendingValidationRequests[textDocument.uri];
    if (request) {
        clearTimeout(request);
        delete pendingValidationRequests[textDocument.uri];
    }
}
function triggerValidation(textDocument) {
    cleanPendingValidation(textDocument);
    pendingValidationRequests[textDocument.uri] = setTimeout(() => {
        delete pendingValidationRequests[textDocument.uri];
        validateTextDocument(textDocument);
    }, validationDelayMs);
}
function validateTextDocument(textDocument) {
    if (textDocument.getText().length === 0) {
        connection.sendDiagnostics({ uri: textDocument.uri, diagnostics: [] });
        return;
    }
    if (isKubernetes(textDocument)) {
        generalYamlValidator(textDocument).then(function (generalResults) {
            specificYamlValidator(textDocument).then(function (specificResults) {
                let generalDiagnostics = generalResults == null ? [] : generalResults;
                let diagnostics = generalDiagnostics.concat(specificResults.items);
                connection.sendDiagnostics({ uri: textDocument.uri, diagnostics: removeDuplicates(diagnostics) });
            });
        });
    }
    else {
        generalYamlValidator(textDocument).then(function (generalResults) {
            connection.sendDiagnostics({ uri: textDocument.uri, diagnostics: removeDuplicates(generalResults) });
        });
    }
}
function isKubernetes(textDocument) {
    for (let path in specificValidatorPaths) {
        let globPath = specificValidatorPaths[path];
        let fpa = new jsonSchemaService_1.FilePatternAssociation(globPath);
        if (fpa.matchesPattern(textDocument.uri)) {
            return true;
        }
    }
    return false;
}
function generalYamlValidator(textDocument) {
    //Validator for regular yaml files
    let jsonDocument = getJSONDocument(textDocument);
    let diagnostics = [];
    return languageService.doValidation(textDocument, jsonDocument).then(function (results) {
        for (let diagnosticItem in results) {
            results[diagnosticItem].severity = 1; //Convert all warnings to errors
            diagnostics.push(results[diagnosticItem]);
        }
        return diagnostics;
        // Send the computed diagnostics to VSCode.
        //connection.sendDiagnostics({ uri: textDocument.uri, diagnostics: removeDuplicates(diagnostics) });
    }, function (error) { });
}
function removeDuplicates(objArray) {
    let nonDuplicateSet = new Set();
    let nonDuplicateArr = [];
    for (let obj in objArray) {
        let currObj = objArray[obj];
        let stringifiedObj = JSON.stringify(currObj);
        if (!nonDuplicateSet.has(stringifiedObj)) {
            nonDuplicateArr.push(currObj);
            nonDuplicateSet.add(stringifiedObj);
        }
    }
    return nonDuplicateArr;
}
function specificYamlValidator(textDocument) {
    //Validator for kubernetes/kedge files
    let diagnostics = [];
    let yamlDoc = yaml_ast_parser_1.load(textDocument.getText(), {});
    return customLanguageService.doValidation(textDocument, yamlDoc).then(function (result) {
        // for(let x = 0; x < result.items.length; x++){
        // 	diagnostics.push(result.items[x]);
        // }
        // Send the computed diagnostics to VSCode.
        return result;
        //connection.sendDiagnostics({ uri: textDocument.uri, diagnostics: removeDuplicates(diagnostics) });
    }, function (error) { });
}
connection.onDidChangeWatchedFiles((change) => {
    // Monitored files have changed in VSCode
    let hasChanges = false;
    change.changes.forEach(c => {
        if (languageService.resetSchema(c.uri)) {
            hasChanges = true;
        }
    });
    if (hasChanges) {
        documents.all().forEach(validateTextDocument);
    }
});
let yamlDocuments = languageModelCache_1.getLanguageModelCache(10, 60, document => languageService.parseYAMLDocument(document));
documents.onDidClose(e => {
    yamlDocuments.onDocumentRemoved(e.document);
});
connection.onShutdown(() => {
    yamlDocuments.dispose();
});
function getJSONDocument(document) {
    return yamlDocuments.get(document);
}
// This handler provides the initial list of the completion items.
connection.onCompletion(textDocumentPosition => {
    let document = documents.get(textDocumentPosition.textDocument.uri);
    return completionHelper(document, textDocumentPosition);
});
function completionHelper(document, textDocumentPosition) {
    /*
    * THIS IS A HACKY VERSION.
    * Needed to get the parent node from the current node to support live autocompletion
    */
    //Get the string we are looking at via a substring
    let linePos = textDocumentPosition.position.line;
    let position = textDocumentPosition.position;
    let lineOffset = arrUtils_1.getLineOffsets(document.getText());
    let start = lineOffset[linePos]; //Start of where the autocompletion is happening
    let end = 0; //End of where the autocompletion is happening
    if (lineOffset[linePos + 1]) {
        end = lineOffset[linePos + 1];
    }
    else {
        end = document.getText().length;
    }
    let textLine = document.getText().substring(start, end);
    //Check if the string we are looking at is a node
    if (textLine.indexOf(":") === -1) {
        //We need to add the ":" to load the nodes
        let newText = "";
        //This is for the empty line case
        if (textLine.trim().length === 0) {
            //Add a temp node that is in the document but we don't use at all.
            if (lineOffset[linePos + 1]) {
                newText = document.getText().substring(0, start + (textLine.length - 1)) + "holder:\r\n" + document.getText().substr(end + 2);
            }
            else {
                newText = document.getText().substring(0, start + (textLine.length)) + "holder:\r\n" + document.getText().substr(end + 2);
            }
        }
        else {
            //Add a semicolon to the end of the current line so we can validate the node
            if (lineOffset[linePos + 1]) {
                newText = document.getText().substring(0, start + (textLine.length - 1)) + ":\r\n" + document.getText().substr(end + 2);
            }
            else {
                newText = document.getText().substring(0, start + (textLine.length)) + ":\r\n" + document.getText().substr(end + 2);
            }
        }
        let yamlDoc = yaml_ast_parser_1.load(newText, {});
        return customLanguageService.doComplete(document, position, yamlDoc);
    }
    else {
        //All the nodes are loaded
        let yamlDoc = yaml_ast_parser_1.load(document.getText(), {});
        position.character = position.character - 1;
        return customLanguageService.doComplete(document, position, yamlDoc);
    }
}
connection.onCompletionResolve(completionItem => {
    return languageService.doResolve(completionItem);
});
connection.onHover(textDocumentPositionParams => {
    let document = documents.get(textDocumentPositionParams.textDocument.uri);
    let yamlDoc = yaml_ast_parser_1.load(document.getText(), {});
    let jsonDocument = getJSONDocument(document);
    if (isKubernetes(textDocumentPositionParams.textDocument)) {
        return customLanguageService.doHover(document, textDocumentPositionParams.position, yamlDoc);
    }
    let hoverItem = languageService.doHover(document, textDocumentPositionParams.position, jsonDocument);
    return hoverItem.then(function (result) {
        return result;
    }, function (error) { });
});
connection.onDocumentSymbol(documentSymbolParams => {
    let document = documents.get(documentSymbolParams.textDocument.uri);
    let jsonDocument = languageService.parseYAMLDocument(document).documents[0];
    return customLanguageService.findDocumentSymbols(document, jsonDocument);
});
connection.onDocumentFormatting(formatParams => {
    let document = documents.get(formatParams.textDocument.uri);
    return languageService.format(document, formatParams.options);
});
// Listen on the connection
connection.listen();
//# sourceMappingURL=server.js.map