"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const languageclient_1 = require("../languageclient");
const convert_1 = require("../convert");
// Public: Listen to diagnostics messages from the language server and publish them
// to the user by way of the Linter Push (Indie) v2 API supported by Atom IDE UI.
class LinterPushV2Adapter {
    // Public: Create a new {LinterPushV2Adapter} that will listen for diagnostics
    // via the supplied {LanguageClientConnection}.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will provide diagnostics.
    constructor(connection) {
        this._diagnosticMap = new Map();
        this._diagnosticCodes = new Map();
        this._indies = new Set();
        connection.onPublishDiagnostics(this.captureDiagnostics.bind(this));
    }
    // Dispose this adapter ensuring any resources are freed and events unhooked.
    dispose() {
        this.detachAll();
    }
    // Public: Attach this {LinterPushV2Adapter} to a given {V2IndieDelegate} registry.
    //
    // * `indie` A {V2IndieDelegate} that wants to receive messages.
    attach(indie) {
        this._indies.add(indie);
        this._diagnosticMap.forEach((value, key) => indie.setMessages(key, value));
        indie.onDidDestroy(() => {
            this._indies.delete(indie);
        });
    }
    // Public: Remove all {V2IndieDelegate} registries attached to this adapter and clear them.
    //
    // * `indie` A {V2IndieDelegate} that wants to receive messages.
    detachAll() {
        this._indies.forEach((i) => i.clearMessages());
        this._indies.clear();
    }
    // Public: Capture the diagnostics sent from a langguage server, convert them to the
    // Linter V2 format and forward them on to any attached {V2IndieDelegate}s.
    //
    // * `params` The {PublishDiagnosticsParams} received from the language server that should
    //            be captured and forwarded on to any attached {V2IndieDelegate}s.
    captureDiagnostics(params) {
        const path = convert_1.default.uriToPath(params.uri);
        const codeMap = new Map();
        const messages = params.diagnostics.map((d) => {
            const linterMessage = this.diagnosticToV2Message(path, d);
            codeMap.set(getCodeKey(linterMessage.location.position, d.message), d.code);
            return linterMessage;
        });
        this._diagnosticMap.set(path, messages);
        this._diagnosticCodes.set(path, codeMap);
        this._indies.forEach((i) => i.setMessages(path, messages));
    }
    // Public: Convert a single {Diagnostic} received from a language server into a single
    // {V2Message} expected by the Linter V2 API.
    //
    // * `path` A string representing the path of the file the diagnostic belongs to.
    // * `diagnostics` A {Diagnostic} object received from the language server.
    //
    // Returns a {V2Message} equivalent to the {Diagnostic} object supplied by the language server.
    diagnosticToV2Message(path, diagnostic) {
        return {
            location: {
                file: path,
                position: convert_1.default.lsRangeToAtomRange(diagnostic.range),
            },
            excerpt: diagnostic.message,
            linterName: diagnostic.source,
            severity: LinterPushV2Adapter.diagnosticSeverityToSeverity(diagnostic.severity || -1),
        };
    }
    // Public: Convert a diagnostic severity number obtained from the language server into
    // the textual equivalent for a Linter {V2Message}.
    //
    // * `severity` A number representing the severity of the diagnostic.
    //
    // Returns a string of 'error', 'warning' or 'info' depending on the severity.
    static diagnosticSeverityToSeverity(severity) {
        switch (severity) {
            case languageclient_1.DiagnosticSeverity.Error:
                return 'error';
            case languageclient_1.DiagnosticSeverity.Warning:
                return 'warning';
            case languageclient_1.DiagnosticSeverity.Information:
            case languageclient_1.DiagnosticSeverity.Hint:
            default:
                return 'info';
        }
    }
    // Private: Get the recorded diagnostic code for a range/message.
    // Diagnostic codes are tricky because there's no suitable place in the Linter API for them.
    // For now, we'll record the original code for each range/message combination and retrieve it
    // when needed (e.g. for passing back into code actions)
    getDiagnosticCode(editor, range, text) {
        const path = editor.getPath();
        if (path != null) {
            const diagnosticCodes = this._diagnosticCodes.get(path);
            if (diagnosticCodes != null) {
                return diagnosticCodes.get(getCodeKey(range, text)) || null;
            }
        }
        return null;
    }
}
exports.default = LinterPushV2Adapter;
function getCodeKey(range, text) {
    return [].concat(...range.serialize(), text).join(',');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGludGVyLXB1c2gtdjItYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9saW50ZXItcHVzaC12Mi1hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsc0RBTTJCO0FBQzNCLHdDQUFpQztBQUVqQyxtRkFBbUY7QUFDbkYsaUZBQWlGO0FBQ2pGO0lBS0UsOEVBQThFO0lBQzlFLCtDQUErQztJQUMvQyxFQUFFO0lBQ0Ysb0dBQW9HO0lBQ3BHLFlBQVksVUFBb0M7UUFSeEMsbUJBQWMsR0FBa0MsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUMxRCxxQkFBZ0IsR0FBb0QsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUM5RSxZQUFPLEdBQThCLElBQUksR0FBRyxFQUFFLENBQUM7UUFPckQsVUFBVSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUN0RSxDQUFDO0lBRUQsNkVBQTZFO0lBQ3RFLE9BQU87UUFDWixJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVELG1GQUFtRjtJQUNuRixFQUFFO0lBQ0YsZ0VBQWdFO0lBQ3pELE1BQU0sQ0FBQyxLQUEyQjtRQUN2QyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDM0UsS0FBSyxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUU7WUFDdEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0IsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsMkZBQTJG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LE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUM5QixFQUFFLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNqQixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3hELEVBQUUsQ0FBQyxDQUFDLGVBQWUsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUM1QixNQUFNLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDO1lBQzlELENBQUM7UUFDSCxDQUFDO1FBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQztJQUNkLENBQUM7Q0FDRjtBQTNHRCxzQ0EyR0M7QUFFRCxvQkFBb0IsS0FBaUIsRUFBRSxJQUFZO0lBQ2pELE1BQU0sQ0FBRSxFQUFZLENBQUMsTUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLFNBQVMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNwRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbGludGVyIGZyb20gJ2F0b20vbGludGVyJztcbmltcG9ydCAqIGFzIGF0b20gZnJvbSAnYXRvbSc7XG5pbXBvcnQge1xuICBEaWFnbm9zdGljLFxuICBEaWFnbm9zdGljQ29kZSxcbiAgRGlhZ25vc3RpY1NldmVyaXR5LFxuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gIFB1Ymxpc2hEaWFnbm9zdGljc1BhcmFtcyxcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XG5cbi8vIFB1YmxpYzogTGlzdGVuIHRvIGRpYWdub3N0aWNzIG1lc3NhZ2VzIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlciBhbmQgcHVibGlzaCB0aGVtXG4vLyB0byB0aGUgdXNlciBieSB3YXkgb2YgdGhlIExpbnRlciBQdXNoIChJbmRpZSkgdjIgQVBJIHN1cHBvcnRlZCBieSBBdG9tIElERSBVSS5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbnRlclB1c2hWMkFkYXB0ZXIge1xuICBwcml2YXRlIF9kaWFnbm9zdGljTWFwOiBNYXA8c3RyaW5nLCBsaW50ZXIuTWVzc2FnZVtdPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBfZGlhZ25vc3RpY0NvZGVzOiBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBEaWFnbm9zdGljQ29kZSB8IG51bGw+PiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBfaW5kaWVzOiBTZXQ8bGludGVyLkluZGllRGVsZWdhdGU+ID0gbmV3IFNldCgpO1xuXG4gIC8vIFB1YmxpYzogQ3JlYXRlIGEgbmV3IHtMaW50ZXJQdXNoVjJBZGFwdGVyfSB0aGF0IHdpbGwgbGlzdGVuIGZvciBkaWFnbm9zdGljc1xuICAvLyB2aWEgdGhlIHN1cHBsaWVkIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259LlxuICAvL1xuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIHByb3ZpZGUgZGlhZ25vc3RpY3MuXG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbikge1xuICAgIGNvbm5lY3Rpb24ub25QdWJsaXNoRGlhZ25vc3RpY3ModGhpcy5jYXB0dXJlRGlhZ25vc3RpY3MuYmluZCh0aGlzKSk7XG4gIH1cblxuICAvLyBEaXNwb3NlIHRoaXMgYWRhcHRlciBlbnN1cmluZyBhbnkgcmVzb3VyY2VzIGFyZSBmcmVlZCBhbmQgZXZlbnRzIHVuaG9va2VkLlxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmRldGFjaEFsbCgpO1xuICB9XG5cbiAgLy8gUHVibGljOiBBdHRhY2ggdGhpcyB7TGludGVyUHVzaFYyQWRhcHRlcn0gdG8gYSBnaXZlbiB7VjJJbmRpZURlbGVnYXRlfSByZWdpc3RyeS5cbiAgLy9cbiAgLy8gKiBgaW5kaWVgIEEge1YySW5kaWVEZWxlZ2F0ZX0gdGhhdCB3YW50cyB0byByZWNlaXZlIG1lc3NhZ2VzLlxuICBwdWJsaWMgYXR0YWNoKGluZGllOiBsaW50ZXIuSW5kaWVEZWxlZ2F0ZSk6IHZvaWQge1xuICAgIHRoaXMuX2luZGllcy5hZGQoaW5kaWUpO1xuICAgIHRoaXMuX2RpYWdub3N0aWNNYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gaW5kaWUuc2V0TWVzc2FnZXMoa2V5LCB2YWx1ZSkpO1xuICAgIGluZGllLm9uRGlkRGVzdHJveSgoKSA9PiB7XG4gICAgICB0aGlzLl9pbmRpZXMuZGVsZXRlKGluZGllKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogUmVtb3ZlIGFsbCB7VjJJbmRpZURlbGVnYXRlfSByZWdpc3RyaWVzIGF0dGFjaGVkIHRvIHRoaXMgYWRhcHRlciBhbmQgY2xlYXIgdGhlbS5cbiAgLy9cbiAgLy8gKiBgaW5kaWVgIEEge1YySW5kaWVEZWxlZ2F0ZX0gdGhhdCB3YW50cyB0byByZWNlaXZlIG1lc3NhZ2VzLlxuICBwdWJsaWMgZGV0YWNoQWxsKCk6IHZvaWQge1xuICAgIHRoaXMuX2luZGllcy5mb3JFYWNoKChpKSA9PiBpLmNsZWFyTWVzc2FnZXMoKSk7XG4gICAgdGhpcy5faW5kaWVzLmNsZWFyKCk7XG4gIH1cblxuICAvLyBQdWJsaWM6IENhcHR1cmUgdGhlIGRpYWdub3N0aWNzIHNlbnQgZnJvbSBhIGxhbmdndWFnZSBzZXJ2ZXIsIGNvbnZlcnQgdGhlbSB0byB0aGVcbiAgLy8gTGludGVyIFYyIGZvcm1hdCBhbmQgZm9yd2FyZCB0aGVtIG9uIHRvIGFueSBhdHRhY2hlZCB7VjJJbmRpZURlbGVnYXRlfXMuXG4gIC8vXG4gIC8vICogYHBhcmFtc2AgVGhlIHtQdWJsaXNoRGlhZ25vc3RpY3NQYXJhbXN9IHJlY2VpdmVkIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHNob3VsZFxuICAvLyAgICAgICAgICAgIGJlIGNhcHR1cmVkIGFuZCBmb3J3YXJkZWQgb24gdG8gYW55IGF0dGFjaGVkIHtWMkluZGllRGVsZWdhdGV9cy5cbiAgcHVibGljIGNhcHR1cmVEaWFnbm9zdGljcyhwYXJhbXM6IFB1Ymxpc2hEaWFnbm9zdGljc1BhcmFtcyk6IHZvaWQge1xuICAgIGNvbnN0IHBhdGggPSBDb252ZXJ0LnVyaVRvUGF0aChwYXJhbXMudXJpKTtcbiAgICBjb25zdCBjb2RlTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gcGFyYW1zLmRpYWdub3N0aWNzLm1hcCgoZCkgPT4ge1xuICAgICAgY29uc3QgbGludGVyTWVzc2FnZSA9IHRoaXMuZGlhZ25vc3RpY1RvVjJNZXNzYWdlKHBhdGgsIGQpO1xuICAgICAgY29kZU1hcC5zZXQoZ2V0Q29kZUtleShsaW50ZXJNZXNzYWdlLmxvY2F0aW9uLnBvc2l0aW9uLCBkLm1lc3NhZ2UpLCBkLmNvZGUpO1xuICAgICAgcmV0dXJuIGxpbnRlck1lc3NhZ2U7XG4gICAgfSk7XG4gICAgdGhpcy5fZGlhZ25vc3RpY01hcC5zZXQocGF0aCwgbWVzc2FnZXMpO1xuICAgIHRoaXMuX2RpYWdub3N0aWNDb2Rlcy5zZXQocGF0aCwgY29kZU1hcCk7XG4gICAgdGhpcy5faW5kaWVzLmZvckVhY2goKGkpID0+IGkuc2V0TWVzc2FnZXMocGF0aCwgbWVzc2FnZXMpKTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIHNpbmdsZSB7RGlhZ25vc3RpY30gcmVjZWl2ZWQgZnJvbSBhIGxhbmd1YWdlIHNlcnZlciBpbnRvIGEgc2luZ2xlXG4gIC8vIHtWMk1lc3NhZ2V9IGV4cGVjdGVkIGJ5IHRoZSBMaW50ZXIgVjIgQVBJLlxuICAvL1xuICAvLyAqIGBwYXRoYCBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHBhdGggb2YgdGhlIGZpbGUgdGhlIGRpYWdub3N0aWMgYmVsb25ncyB0by5cbiAgLy8gKiBgZGlhZ25vc3RpY3NgIEEge0RpYWdub3N0aWN9IG9iamVjdCByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7VjJNZXNzYWdlfSBlcXVpdmFsZW50IHRvIHRoZSB7RGlhZ25vc3RpY30gb2JqZWN0IHN1cHBsaWVkIGJ5IHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXG4gIHB1YmxpYyBkaWFnbm9zdGljVG9WMk1lc3NhZ2UocGF0aDogc3RyaW5nLCBkaWFnbm9zdGljOiBEaWFnbm9zdGljKTogbGludGVyLk1lc3NhZ2Uge1xuICAgIHJldHVybiB7XG4gICAgICBsb2NhdGlvbjoge1xuICAgICAgICBmaWxlOiBwYXRoLFxuICAgICAgICBwb3NpdGlvbjogQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UoZGlhZ25vc3RpYy5yYW5nZSksXG4gICAgICB9LFxuICAgICAgZXhjZXJwdDogZGlhZ25vc3RpYy5tZXNzYWdlLFxuICAgICAgbGludGVyTmFtZTogZGlhZ25vc3RpYy5zb3VyY2UsXG4gICAgICBzZXZlcml0eTogTGludGVyUHVzaFYyQWRhcHRlci5kaWFnbm9zdGljU2V2ZXJpdHlUb1NldmVyaXR5KGRpYWdub3N0aWMuc2V2ZXJpdHkgfHwgLTEpLFxuICAgIH07XG4gIH1cblxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBkaWFnbm9zdGljIHNldmVyaXR5IG51bWJlciBvYnRhaW5lZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgaW50b1xuICAvLyB0aGUgdGV4dHVhbCBlcXVpdmFsZW50IGZvciBhIExpbnRlciB7VjJNZXNzYWdlfS5cbiAgLy9cbiAgLy8gKiBgc2V2ZXJpdHlgIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgc2V2ZXJpdHkgb2YgdGhlIGRpYWdub3N0aWMuXG4gIC8vXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgb2YgJ2Vycm9yJywgJ3dhcm5pbmcnIG9yICdpbmZvJyBkZXBlbmRpbmcgb24gdGhlIHNldmVyaXR5LlxuICBwdWJsaWMgc3RhdGljIGRpYWdub3N0aWNTZXZlcml0eVRvU2V2ZXJpdHkoc2V2ZXJpdHk6IG51bWJlcik6ICdlcnJvcicgfCAnd2FybmluZycgfCAnaW5mbycge1xuICAgIHN3aXRjaCAoc2V2ZXJpdHkpIHtcbiAgICAgIGNhc2UgRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yOlxuICAgICAgICByZXR1cm4gJ2Vycm9yJztcbiAgICAgIGNhc2UgRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmc6XG4gICAgICAgIHJldHVybiAnd2FybmluZyc7XG4gICAgICBjYXNlIERpYWdub3N0aWNTZXZlcml0eS5JbmZvcm1hdGlvbjpcbiAgICAgIGNhc2UgRGlhZ25vc3RpY1NldmVyaXR5LkhpbnQ6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJ2luZm8nO1xuICAgIH1cbiAgfVxuXG4gIC8vIFByaXZhdGU6IEdldCB0aGUgcmVjb3JkZWQgZGlhZ25vc3RpYyBjb2RlIGZvciBhIHJhbmdlL21lc3NhZ2UuXG4gIC8vIERpYWdub3N0aWMgY29kZXMgYXJlIHRyaWNreSBiZWNhdXNlIHRoZXJlJ3Mgbm8gc3VpdGFibGUgcGxhY2UgaW4gdGhlIExpbnRlciBBUEkgZm9yIHRoZW0uXG4gIC8vIEZvciBub3csIHdlJ2xsIHJlY29yZCB0aGUgb3JpZ2luYWwgY29kZSBmb3IgZWFjaCByYW5nZS9tZXNzYWdlIGNvbWJpbmF0aW9uIGFuZCByZXRyaWV2ZSBpdFxuICAvLyB3aGVuIG5lZWRlZCAoZS5nLiBmb3IgcGFzc2luZyBiYWNrIGludG8gY29kZSBhY3Rpb25zKVxuICBwdWJsaWMgZ2V0RGlhZ25vc3RpY0NvZGUoZWRpdG9yOiBhdG9tLlRleHRFZGl0b3IsIHJhbmdlOiBhdG9tLlJhbmdlLCB0ZXh0OiBzdHJpbmcpOiBEaWFnbm9zdGljQ29kZSB8IG51bGwge1xuICAgIGNvbnN0IHBhdGggPSBlZGl0b3IuZ2V0UGF0aCgpO1xuICAgIGlmIChwYXRoICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGRpYWdub3N0aWNDb2RlcyA9IHRoaXMuX2RpYWdub3N0aWNDb2Rlcy5nZXQocGF0aCk7XG4gICAgICBpZiAoZGlhZ25vc3RpY0NvZGVzICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNDb2Rlcy5nZXQoZ2V0Q29kZUtleShyYW5nZSwgdGV4dCkpIHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvZGVLZXkocmFuZ2U6IGF0b20uUmFuZ2UsIHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiAoW10gYXMgYW55W10pLmNvbmNhdCguLi5yYW5nZS5zZXJpYWxpemUoKSwgdGV4dCkuam9pbignLCcpO1xufVxuIl19